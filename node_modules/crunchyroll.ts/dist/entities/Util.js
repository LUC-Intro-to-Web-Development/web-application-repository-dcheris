"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.Util = void 0;
var axios_1 = __importDefault(require("axios"));
var child_process_1 = __importDefault(require("child_process"));
var eloquent_ffmpeg_1 = require("eloquent-ffmpeg");
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var util_1 = __importDefault(require("util"));
var which_1 = __importDefault(require("which"));
var Anime_1 = require("./Anime");
var Episode_1 = require("./Episode");
var exec = util_1["default"].promisify(child_process_1["default"].exec);
var Util = /** @class */ (function () {
    function Util() {
    }
    Util.multiTrim = function (str) {
        return str.replace(/^\s+/gm, "").replace(/\s+$/gm, "").replace(/newline/g, " ");
    };
    Util.parsem3u8 = function (manifest) {
        var m3u8Parser = require("m3u8-parser");
        var parser = new m3u8Parser.Parser();
        parser.push(manifest);
        parser.end();
        return parser.manifest;
    };
    Util.parseTemplate = function (episode, template, playlist, language) {
        var _a, _b, _c, _d, _e;
        if (!template)
            template = "{seasonTitle} {episodeNumber}";
        var resolution = playlist ? ((_b = (_a = playlist.attributes) === null || _a === void 0 ? void 0 : _a.RESOLUTION.height) !== null && _b !== void 0 ? _b : 720) : "";
        return template
            .replace(/{seriesTitle}/gi, (_c = episode.series_name) === null || _c === void 0 ? void 0 : _c.replace(/-/g, " ").replace(/[<>:"|?*.]/g, "").replace(/[\/\\]/g, " "))
            .replace(/{seasonTitle}/gi, (_d = episode.collection_name) === null || _d === void 0 ? void 0 : _d.replace(/-/g, " ").replace(/[<>:"|?*.]/g, "").replace(/[\/\\]/g, " "))
            .replace(/{episodeTitle}/gi, (_e = episode.name) === null || _e === void 0 ? void 0 : _e.replace(/-/g, " ").replace(/[<>:"|?*.]/g, "").replace(/[\/\\]/g, " "))
            .replace(/{episodeNumber}/gi, episode.episode_number)
            .replace(/{resolution}/gi, resolution + "p")
            .replace(/{language}/gi, Util.parseLocale(language !== null && language !== void 0 ? language : "enUS"));
    };
    Util.parseDuration = function (file, ffmpegPath) { return __awaiter(void 0, void 0, void 0, function () {
        var command, str, tim, duration;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    command = "\"" + (ffmpegPath ? ffmpegPath : "ffmpeg") + "\" -i \"" + file + "\"";
                    return [4 /*yield*/, exec(command).then(function (s) { return s.stdout; })["catch"](function (e) { return e.stderr; })];
                case 1:
                    str = _b.sent();
                    tim = (_a = str.match(/(?<=Duration: )(.*?)(?=,)/)) === null || _a === void 0 ? void 0 : _a[0].split(":").map(function (n) { return Number(n); });
                    if (!tim)
                        return [2 /*return*/, 0];
                    duration = (tim[0] * 60 * 60) + (tim[1] * 60) + tim[2];
                    return [2 /*return*/, duration * 1000];
            }
        });
    }); };
    Util.formatMS = function (ms) {
        var sec = ms / 1000;
        var hours = parseInt(String(Math.floor(sec / 3600)), 10);
        var minutes = parseInt(String(Math.floor(sec / 60) % 60), 10);
        var seconds = parseInt(String(sec % 60), 10);
        var str = [hours, minutes, seconds]
            .map(function (v) { return v < 10 ? "0" + v : v; })
            .filter(function (v, i) { return v !== "00" || i > 0; })
            .join(":");
        return str.startsWith("0") ? str.slice(1) : str;
    };
    Util.parseAnime = function (animeResolvable) { return __awaiter(void 0, void 0, void 0, function () {
        var anime, phrases, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    anime = null;
                    if (!(animeResolvable.hasOwnProperty("series_id") && !animeResolvable.hasOwnProperty("collection_id"))) return [3 /*break*/, 1];
                    anime = animeResolvable;
                    return [3 /*break*/, 7];
                case 1:
                    phrases = animeResolvable.hasOwnProperty("collection_id") ? animeResolvable.name.split(/ +/g) : animeResolvable.split(/ +/g);
                    _b.label = 2;
                case 2:
                    if (!!anime) return [3 /*break*/, 7];
                    if (!phrases.length)
                        return [2 /*return*/, Promise.reject("no anime found for " + animeResolvable)];
                    _b.label = 3;
                case 3:
                    _b.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, Anime_1.Anime.get(phrases.join(" "))];
                case 4:
                    anime = (_b.sent());
                    return [3 /*break*/, 6];
                case 5:
                    _a = _b.sent();
                    phrases.pop();
                    return [3 /*break*/, 6];
                case 6: return [3 /*break*/, 2];
                case 7: return [2 /*return*/, anime];
            }
        });
    }); };
    Util.parseLocale = function (locale) {
        if (locale === "jaJP")
            return "Japanese";
        if (locale === "enUS")
            return "English";
        if (locale === "enGB")
            return "English";
        if (locale === "esES")
            return "Spanish";
        if (locale === "esLA")
            return "Spanish";
        if (locale === "frFR")
            return "French";
        if (locale === "deDE")
            return "German";
        if (locale === "itIT")
            return "Italian";
        if (locale === "ruRU")
            return "Russian";
        if (locale === "ptBR")
            return "Portuguese";
        if (locale === "ptPT")
            return "Portuguese";
        if (locale === "arME")
            return "Arabic";
        if (locale.toLowerCase() === "japanese")
            return "jaJP";
        if (locale.toLowerCase() === "english")
            return "enUS";
        if (locale.toLowerCase() === "spanish")
            return "esES";
        if (locale.toLowerCase() === "french")
            return "frFR";
        if (locale.toLowerCase() === "german")
            return "deDE";
        if (locale.toLowerCase() === "italian")
            return "itIT";
        if (locale.toLowerCase() === "russian")
            return "ruRU";
        if (locale.toLowerCase() === "portuguese")
            return "ptPT";
        if (locale.toLowerCase() === "arabic")
            return "arME";
        return "None";
    };
    Util.findQuality = function (episode, quality, stream) { return __awaiter(void 0, void 0, void 0, function () {
        var found, streams, i, manifest, m3u8, playlist;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!quality)
                        quality = 1080;
                    found = [];
                    streams = stream ? [stream] : episode.stream_data.streams.map(function (s) { return s.url; });
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < streams.length)) return [3 /*break*/, 4];
                    return [4 /*yield*/, axios_1["default"].get(streams[i]).then(function (r) { return r.data; })];
                case 2:
                    manifest = _a.sent();
                    m3u8 = Util.parsem3u8(manifest);
                    if (!m3u8.playlists)
                        return [2 /*return*/, m3u8];
                    playlist = m3u8.playlists.find(function (p) { return p.attributes.RESOLUTION.height === quality; });
                    if (!playlist && quality >= 720)
                        playlist = m3u8.playlists.find(function (p) { return p.attributes.RESOLUTION.height === 720; });
                    if (!playlist && quality >= 480)
                        playlist = m3u8.playlists.find(function (p) { return p.attributes.RESOLUTION.height === 480; });
                    if (!playlist && quality >= 360)
                        playlist = m3u8.playlists.find(function (p) { return p.attributes.RESOLUTION.height === 360; });
                    if (!playlist && quality >= 240)
                        playlist = m3u8.playlists.find(function (p) { return p.attributes.RESOLUTION.height === 240; });
                    if (playlist)
                        found.push(playlist);
                    _a.label = 3;
                case 3:
                    i++;
                    return [3 /*break*/, 1];
                case 4:
                    if (!found[0])
                        return [2 /*return*/, null];
                    return [2 /*return*/, found.reduce(function (prev, curr) { return curr.attributes.RESOLUTION.height > prev.attributes.RESOLUTION.height ? curr : prev; })];
            }
        });
    }); };
    Util.parseDest = function (episode, format, dest, template, playlist, language) {
        if (!dest)
            dest = "./";
        if (!path_1["default"].isAbsolute(dest)) {
            var local = __dirname.includes("node_modules") ? path_1["default"].join(__dirname, "../../../../") : path_1["default"].join(__dirname, "../../");
            dest = path_1["default"].join(local, dest);
        }
        if (format === "png") {
            return dest + "/" + Util.parseTemplate(episode, template, playlist, language);
        }
        if (!path_1["default"].extname(dest))
            dest += "/" + Util.parseTemplate(episode, template, playlist, language) + "." + format;
        return dest;
    };
    Util.downloadEpisode = function (episodeResolvable, dest, options, videoProgress) { return __awaiter(void 0, void 0, void 0, function () {
        var episode, format, playlist, uri, resolution, folder, codec, ffmpegArgs, video, i, metadataPath, text, duration, process, killed, _a, _b, progress, percent, result, e_1_1, err_1;
        var _c;
        var e_1, _d;
        var _e, _f, _g;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    if (!options)
                        options = {};
                    if (options.ffmpegPath) {
                        eloquent_ffmpeg_1.setFFmpegPath(options.ffmpegPath);
                    }
                    else {
                        eloquent_ffmpeg_1.setFFmpegPath(which_1["default"].sync("ffmpeg"));
                    }
                    episode = null;
                    if (!episodeResolvable.hasOwnProperty("url")) return [3 /*break*/, 1];
                    episode = episodeResolvable;
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, Episode_1.Episode.get(episodeResolvable, { preferSub: options.preferSub, preferDub: options.preferDub, language: options.language })];
                case 2:
                    episode = _h.sent();
                    _h.label = 3;
                case 3:
                    format = "mp4";
                    if (options.audioOnly)
                        format = "mp3";
                    if (options.skipConversion)
                        format = "m3u8";
                    if (options.softSubs)
                        format = "mkv";
                    if (options.codec === "vp8")
                        format = "webm";
                    return [4 /*yield*/, Util.findQuality(episode, options.resolution, options.playlist)];
                case 4:
                    playlist = _h.sent();
                    if (!playlist)
                        return [2 /*return*/, Promise.reject("can't download this episode (is it premium only?)")];
                    uri = playlist.uri ? playlist.uri : options.playlist;
                    resolution = (_f = (_e = playlist.attributes) === null || _e === void 0 ? void 0 : _e.RESOLUTION.height) !== null && _f !== void 0 ? _f : 720;
                    dest = Util.parseDest(episode, format, dest, options.template, playlist, options.language);
                    folder = path_1["default"].dirname(dest);
                    if (!fs_1["default"].existsSync(folder))
                        fs_1["default"].mkdirSync(folder, { recursive: true });
                    if (options.skipConversion)
                        return [2 /*return*/, uri];
                    codec = ["-c", "copy", "-bsf:a", "aac_adtstoasc"];
                    if (options.codec === "h.264")
                        codec = ["-c:v", "libx264", "-preset", "fast", "-c:a", "aac", "-bsf:a", "aac_adtstoasc"];
                    if (options.codec === "h.265")
                        codec = ["-c:v", "libx265", "-preset", "fast", "-c:a", "aac", "-bsf:a", "aac_adtstoasc"];
                    if (options.codec === "vp8")
                        codec = ["-c:v", "libvpx", "-preset", "fast", "-b:v", "1M", "-c:a", "libvorbis"];
                    if (options.codec === "vp9")
                        codec = ["-c:v", "libvpx-vp9", "-preset", "fast", "-b:v", "0", "-c:a", "libopus"];
                    ffmpegArgs = __spread(codec, ["-crf", "" + ((options === null || options === void 0 ? void 0 : options.quality) || 23), "-pix_fmt", "yuv420p", "-movflags", "+faststart"]);
                    if (options.audioOnly)
                        ffmpegArgs = [];
                    video = eloquent_ffmpeg_1.ffmpeg();
                    video.input(uri);
                    if (options.softSubs && options.subtitles) {
                        ffmpegArgs.unshift("-map", "0", "-dn", "-map", "-0:s", "-map", "-0:d");
                        for (i = 0; i < options.subtitles.length; i++) {
                            video.input(options.subtitles[i]);
                            ffmpegArgs.push("-map", i + 1 + ":0");
                            if ((_g = options.subtitleNames) === null || _g === void 0 ? void 0 : _g[i])
                                ffmpegArgs.push("-metadata:s:s:" + i, "title=" + options.subtitleNames[i]);
                        }
                    }
                    metadataPath = "";
                    if (options.intro) {
                        text = ";FFMETADATA1\ntitle=" + episode.collection_name + " " + episode.episode_number + "\n\n";
                        text += "[CHAPTER]\nTIMEBASE=1/1000\nSTART=" + options.intro.startTime * 1000 + "\nEND=" + options.intro.endTime * 1000 + "\ntitle=Intro";
                        metadataPath = path_1["default"].join(__dirname, "metadata.txt");
                        fs_1["default"].writeFileSync(metadataPath, text);
                        video.input(metadataPath);
                        ffmpegArgs.push("-map_metadata", "1", "-map_chapters", "1");
                    }
                    return [4 /*yield*/, Util.parseDuration(uri, options.ffmpegPath)];
                case 5:
                    duration = _h.sent();
                    (_c = video.output(dest)).args.apply(_c, __spread(ffmpegArgs));
                    return [4 /*yield*/, video.spawn()];
                case 6:
                    process = _h.sent();
                    killed = false;
                    if (!videoProgress) return [3 /*break*/, 21];
                    _h.label = 7;
                case 7:
                    _h.trys.push([7, 15, 16, 21]);
                    _a = __asyncValues(process.progress());
                    _h.label = 8;
                case 8: return [4 /*yield*/, _a.next()];
                case 9:
                    if (!(_b = _h.sent(), !_b.done)) return [3 /*break*/, 14];
                    progress = _b.value;
                    percent = (progress.time / duration) * 100;
                    result = videoProgress(__assign(__assign({}, progress), { percent: percent, resolution: resolution, duration: duration }), function () { return process.resume(); });
                    if (!(result === "pause")) return [3 /*break*/, 10];
                    process.pause();
                    return [3 /*break*/, 13];
                case 10:
                    if (!(result === "kill")) return [3 /*break*/, 11];
                    killed = true;
                    process.kill("SIGKILL");
                    return [3 /*break*/, 13];
                case 11:
                    if (!(result === "stop")) return [3 /*break*/, 13];
                    return [4 /*yield*/, process.abort()["catch"](function () { return null; })];
                case 12:
                    _h.sent();
                    _h.label = 13;
                case 13: return [3 /*break*/, 8];
                case 14: return [3 /*break*/, 21];
                case 15:
                    e_1_1 = _h.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 21];
                case 16:
                    _h.trys.push([16, , 19, 20]);
                    if (!(_b && !_b.done && (_d = _a["return"]))) return [3 /*break*/, 18];
                    return [4 /*yield*/, _d.call(_a)];
                case 17:
                    _h.sent();
                    _h.label = 18;
                case 18: return [3 /*break*/, 20];
                case 19:
                    if (e_1) throw e_1.error;
                    return [7 /*endfinally*/];
                case 20: return [7 /*endfinally*/];
                case 21:
                    _h.trys.push([21, 23, , 24]);
                    return [4 /*yield*/, process.complete()];
                case 22:
                    _h.sent();
                    return [3 /*break*/, 24];
                case 23:
                    err_1 = _h.sent();
                    if (!killed)
                        return [2 /*return*/, Promise.reject(err_1)];
                    return [3 /*break*/, 24];
                case 24:
                    if (metadataPath)
                        fs_1["default"].unlinkSync(metadataPath);
                    return [2 /*return*/, dest];
            }
        });
    }); };
    Util.downloadAnime = function (animeResolvable, destFolder, options, totalProgress, videoProgress) { return __awaiter(void 0, void 0, void 0, function () {
        var episodes, resultArray, i, result, stop_1, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!options)
                        options = {};
                    return [4 /*yield*/, Anime_1.Anime.episodes(animeResolvable, { preferSub: options.preferSub, preferDub: options.preferDub })];
                case 1:
                    episodes = _b.sent();
                    resultArray = [];
                    i = 0;
                    _b.label = 2;
                case 2:
                    if (!(i < episodes.length)) return [3 /*break*/, 7];
                    _b.label = 3;
                case 3:
                    _b.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, Util.downloadEpisode(episodes[i], destFolder, options, videoProgress)];
                case 4:
                    result = _b.sent();
                    resultArray.push(result);
                    stop_1 = totalProgress ? totalProgress(i + 1, episodes.length) : false;
                    if (stop_1)
                        return [3 /*break*/, 7];
                    return [3 /*break*/, 6];
                case 5:
                    _a = _b.sent();
                    return [3 /*break*/, 6];
                case 6:
                    i++;
                    return [3 /*break*/, 2];
                case 7: return [2 /*return*/, resultArray];
            }
        });
    }); };
    Util.downloadThumbnails = function (episodeResolvable, dest, options) { return __awaiter(void 0, void 0, void 0, function () {
        var episode, folder, video, process;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!options)
                        options = {};
                    if (options.ffmpegPath) {
                        eloquent_ffmpeg_1.setFFmpegPath(options.ffmpegPath);
                    }
                    else {
                        eloquent_ffmpeg_1.setFFmpegPath(which_1["default"].sync("ffmpeg"));
                    }
                    episode = null;
                    if (!episodeResolvable.hasOwnProperty("url")) return [3 /*break*/, 1];
                    episode = episodeResolvable;
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, Episode_1.Episode.get(episodeResolvable)];
                case 2:
                    episode = _a.sent();
                    _a.label = 3;
                case 3:
                    folder = Util.parseDest(episode, "png", dest, options.template, options.language);
                    if (!fs_1["default"].existsSync(folder))
                        fs_1["default"].mkdirSync(folder, { recursive: true });
                    video = eloquent_ffmpeg_1.ffmpeg();
                    video.input(episode.bif_url);
                    video.output(folder + "/thumb%d.png");
                    return [4 /*yield*/, video.spawn()];
                case 4:
                    process = _a.sent();
                    return [4 /*yield*/, process.complete()];
                case 5:
                    _a.sent();
                    return [2 /*return*/, folder];
            }
        });
    }); };
    return Util;
}());
exports.Util = Util;
