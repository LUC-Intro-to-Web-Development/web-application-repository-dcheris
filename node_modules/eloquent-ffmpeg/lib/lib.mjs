/**
 * eloquent-ffmpeg v0.13.0-alpha.0 â€” git 3808291d880e
 * Fri, 20 Nov 2020 17:45:22 GMT
 * https://github.com/FedericoCarboni/eloquent-ffmpeg#readme
 * @license MIT
 * @author Federico Carboni
 */
import { existsSync, lstatSync } from 'fs';
import { resolve } from 'path';
import { spawn as spawn$1 } from 'child_process';
import { createRequire } from 'module';
import { Readable } from 'stream';
import { createServer } from 'net';
import crypto from 'crypto';
import { createInterface } from 'readline';

const { FFMPEG_PATH, FFPROBE_PATH } = process.env;
let ffmpegPath = FFMPEG_PATH ? resolvePath(FFMPEG_PATH) : void 0;
function setFFmpegPath(path) {
    const newPath = resolvePath(path);
    if (newPath === void 0)
        throw new TypeError(`'${path}' is not a file`);
    ffmpegPath = newPath;
}
function getFFmpegPath() {
    if (ffmpegPath === void 0)
        throw new TypeError('Cannot find ffmpeg, make sure to set FFMPEG_PATH or call setFFmpegPath()');
    return ffmpegPath;
}
let ffprobePath = FFPROBE_PATH ? resolvePath(FFPROBE_PATH) : void 0;
function setFFprobePath(path) {
    const newPath = resolvePath(path);
    if (newPath === void 0)
        throw new TypeError(`'${path}' is not a file`);
    ffprobePath = newPath;
}
function getFFprobePath() {
    if (ffprobePath === void 0)
        throw new TypeError('Cannot find ffprobe, make sure to set FFPROBE_PATH or call setFFprobePath()');
    return ffprobePath;
}
function resolvePath(path) {
    const fullpath = resolve(path);
    if (existsSync(fullpath) && lstatSync(fullpath).isFile())
        return fullpath;
    return void 0;
}

const _require = createRequire(import.meta.url);

const isWin32 = process.platform === 'win32';
const DEV_NULL = isWin32 ? 'NUL' : '/dev/null';
const IGNORED_ERRORS = new Set(['ECONNRESET', 'EPIPE', 'EOF']);
const isNullish = (o) => o === void 0 || o === null;
const isObject = (o) => o !== null && typeof o === 'object';
const isStream = (o) => isObject(o) && typeof o.pipe === 'function';
const isReadableStream = (o) => {
    try {
        return isStream(o) &&
            'readable' in o && o.readable !== false &&
            typeof o._read === 'function' &&
            typeof o._readableState === 'object';
    }
    catch (_a) {
        return false;
    }
};
const read = (stream) => (new Promise((resolve, reject) => {
    const chunks = [];
    const unlisten = () => {
        stream.off('readable', onReadable);
        stream.off('error', onError);
        stream.off('end', onEnd);
    };
    const onReadable = () => {
        let chunk;
        while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
        }
    };
    const onEnd = () => {
        const buffer = Buffer.concat(chunks);
        unlisten();
        resolve(buffer);
    };
    const onError = (reason) => {
        unlisten();
        reject(reason);
    };
    stream.on('readable', onReadable);
    stream.on('end', onEnd);
    stream.on('error', onError);
    stream.resume();
}));
const write = (stream, chunk) => (new Promise((resolve, reject) => {
    stream.write(chunk, () => {
        stream.off('error', reject);
        resolve();
    });
    stream.once('error', reject);
}));
const toReadable = (source) => (isReadableStream(source) ? source : Readable.from(source instanceof Uint8Array ? [source] : source, { objectMode: false }));
const flatMap = Array.prototype.flatMap
    ? (array, callback) => array.flatMap(callback)
    : (array, callback) => [].concat(...array.map(callback));
async function fromAsyncIterable(iterable) {
    const array = [];
    for await (const item of iterable)
        array.push(item);
    return array;
}
let pause;
let resume;
if (isWin32) {
    (() => {
        try {
            const ntsuspend = _require('ntsuspend');
            pause = (p) => ntsuspend.suspend(p.pid);
            resume = (p) => ntsuspend.resume(p.pid);
        }
        catch (_a) {
            const error = new TypeError('Cannot require() ntsuspend https://git.io/JTqA9#error-ntsuspend');
            pause = resume = () => { throw error; };
        }
    })();
}
else {
    pause = (p) => p.kill('SIGSTOP');
    resume = (p) => p.kill('SIGCONT');
}

async function getVersion(ffmpegPath = getFFmpegPath()) {
    const lines = await getLines(ffmpegPath, ['-version']);
    const split = lines[0].slice(15).split(' ');
    const version = split[0];
    const copyright = split.slice(1).join(' ');
    const configuration = lines[2].split(' ').slice(1);
    function getVersion(line) {
        const split = line.slice(15, 25).split('.');
        return split.map((s) => s.trim()).join('.');
    }
    const libavutil = getVersion(lines[3]);
    const libavcodec = getVersion(lines[4]);
    const libavformat = getVersion(lines[5]);
    const libavdevice = getVersion(lines[6]);
    const libavfilter = getVersion(lines[7]);
    const libswscale = getVersion(lines[8]);
    const libswresample = getVersion(lines[9]);
    const libpostproc = getVersion(lines[10]);
    return {
        copyright,
        version,
        configuration,
        libavutil,
        libavcodec,
        libavformat,
        libavdevice,
        libavfilter,
        libswscale,
        libswresample,
        libpostproc
    };
}
async function getDemuxers(ffmpegPath = getFFmpegPath()) {
    const lines = await getLines(ffmpegPath, ['-demuxers']);
    const demuxers = new Set();
    for (const line of lines.slice(4)) {
        demuxers.add(parseLine(line));
    }
    return demuxers;
}
async function getMuxers(ffmpegPath = getFFmpegPath()) {
    const lines = await getLines(ffmpegPath, ['-muxers']);
    const muxers = new Set();
    for (const line of lines.slice(4)) {
        muxers.add(parseLine(line));
    }
    return muxers;
}
async function getFormats(ffmpegPath = getFFmpegPath()) {
    const lines = await getLines(ffmpegPath, ['-formats']);
    const formats = new Set();
    for (const line of lines.slice(4)) {
        formats.add(parseLine(line));
    }
    return formats;
}
async function getEncoders(ffmpegPath = getFFmpegPath()) {
    const lines = await getLines(ffmpegPath, ['-encoders']);
    return parseCodecs(lines, 1);
}
async function getDecoders(ffmpegPath = getFFmpegPath()) {
    const lines = await getLines(ffmpegPath, ['-decoders']);
    return parseCodecs(lines, 1);
}
async function getCodecs(ffmpegPath = getFFmpegPath()) {
    const lines = await getLines(ffmpegPath, ['-codecs']);
    return parseCodecs(lines, 3);
}
async function getPixelFormats(ffmpegPath = getFFmpegPath()) {
    const lines = await getLines(ffmpegPath, ['-pix_fmts']);
    const pixelFormats = new Set();
    for (const line of lines.slice(8)) {
        pixelFormats.add(parseLine(line, 6));
    }
    return pixelFormats;
}
async function getFilters(ffmpegPath = getFFmpegPath()) {
    const lines = await getLines(ffmpegPath, ['-filters']);
    const filters = {
        video: new Set(),
        audio: new Set(),
    };
    for (const line of lines.slice(8)) {
        const filter = parseLine(line, 5);
        if (line[23] === 'V')
            filters.video.add(filter);
        else if (line[23] === 'A')
            filters.audio.add(filter);
    }
    return filters;
}
function parseCodecs(lines, flag) {
    const codecs = {
        video: new Set(),
        audio: new Set(),
        subtitle: new Set(),
        data: new Set(),
    };
    for (const line of lines.slice(10)) {
        const name = parseLine(line, 8);
        switch (line[flag]) {
            case 'V':
                codecs.video.add(name);
                break;
            case 'A':
                codecs.audio.add(name);
                break;
            case 'S':
                codecs.subtitle.add(name);
                break;
            case 'D':
                codecs.data.add(name);
        }
    }
    return codecs;
}
function parseLine(line, i = 4) {
    return line.slice(i, line.slice(i).indexOf(' ') + i);
}
async function getLines(ffmpegPath, args) {
    const process = spawn$1(ffmpegPath, args, { stdio: 'pipe' });
    return (await read(process.stdout)).toString('utf-8').trim().split(/\r\n|[\r\n]/);
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

const rnds8 = new Uint8Array(16);
function rng() {
  return crypto.randomFillSync(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}

const getSocketPath = isWin32 ? () => (`//./pipe/ffmpeg-ipc-${v4()}.sock`) : () => (`/tmp/ffmpeg-ipc-${v4()}.sock`);
const getSocketUrl = isWin32 ? (path) => (`file:${path}`) : (path) => (`unix:${path}`);
const createSocketServer = (path) => (new Promise((resolve) => {
    const server = createServer();
    server.listen(path, () => resolve(server));
}));

class FFmpegError extends Error {
    constructor(message, stderr) {
        super(message);
        this.stderr = stderr;
    }
}
class FFprobeError extends Error {
    constructor(message, stderr, code) {
        super(message);
        this.stderr = stderr;
        this.code = code;
    }
}
function extractMessage(stderr) {
    let message;
    for (const line of stderr) {
        if (!message && line.includes(': '))
            message = line.slice(line.indexOf(': ') + 2);
        if (line.startsWith('[NULL @ '))
            message = line.slice(line.indexOf('] ') + 2);
    }
    return message;
}

var _raw;
async function probe(source, options = {}) {
    const { probeSize, analyzeDuration, ffprobePath = getFFprobePath(), logLevel = LogLevel.Error, format, args = [], spawnOptions = {}, } = options;
    const ffprobe = spawn$1(ffprobePath, [
        '-v', logLevel.toString(),
        ...(probeSize !== void 0 ? ['-probesize', probeSize.toString()] : []),
        ...(analyzeDuration !== void 0 ? ['-analyzeduration', (analyzeDuration * 1000).toString()] : []),
        '-of', 'json=c=1',
        '-show_format',
        '-show_streams',
        '-show_chapters',
        '-show_error',
        ...args,
        ...(format !== void 0 ? ['-f', format] : []),
        '-i',
        typeof source === 'string' ? source : 'pipe:0'
    ], {
        stdio: 'pipe',
        ...spawnOptions,
    });
    const { stdin, stdout, stderr } = ffprobe;
    const extractError = async (error) => {
        const logs = [];
        if (stderr.readable)
            for await (const line of createInterface(stderr)) {
                logs.push(line);
            }
        return new FFprobeError(error.string, logs, error.code);
    };
    try {
        if (source instanceof Uint8Array) {
            writeStdin(stdin, source);
        }
        else if (typeof source !== 'string') {
            pipeStdin(stdin, toReadable(source));
        }
        const output = await read(stdout);
        const raw = JSON.parse(output.toString('utf-8'));
        if (raw.error)
            throw await extractError(raw.error);
        await new Promise((resolve) => ffprobe.once('exit', resolve));
        return new Result(raw);
    }
    finally {
        if (isNullish(ffprobe.exitCode))
            ffprobe.kill();
    }
}
class Result {
    constructor(raw) {
        _raw.set(this, void 0);
        __classPrivateFieldSet(this, _raw, raw);
        if (raw.format.format_name)
            this.format = raw.format.format_name;
        if (raw.format.format_long_name)
            this.formatName = raw.format.format_long_name;
        this.start = +raw.format.start_time * 1000 | 0;
        this.duration = +raw.format.duration * 1000 | 0;
        this.score = raw.format.probe_score >>> 0;
        if (raw.format.tags)
            this.tags = tags(raw.format.tags);
    }
    unwrap() {
        return __classPrivateFieldGet(this, _raw);
    }
}
_raw = new WeakMap();
function writeStdin(stdin, u8) {
    return new Promise((resolve, reject) => {
        const unlisten = () => {
            stdin.off('error', onError);
            stdin.off('close', onClose);
        };
        const onError = (error) => {
            if (!IGNORED_ERRORS.has(error.code)) {
                unlisten();
                reject(error);
            }
        };
        const onClose = () => {
            unlisten();
            resolve();
        };
        stdin.on('close', onClose);
        stdin.on('error', onError);
        stdin.end(u8);
    });
}
function pipeStdin(stdin, stream) {
    return new Promise((resolve, reject) => {
        const unlisten = () => {
            stream.off('error', onStreamError);
            stdin.off('error', onError);
            stdin.off('close', onClose);
        };
        const onError = (error) => {
            if (!IGNORED_ERRORS.has(error.code)) {
                unlisten();
                reject(error);
            }
        };
        const onStreamError = (error) => {
            if (stdin.writable)
                stdin.end();
            unlisten();
            reject(error);
        };
        const onClose = () => {
            unlisten();
            resolve();
        };
        stream.on('error', onStreamError);
        stdin.on('close', onClose);
        stdin.on('error', onError);
        stream.pipe(stdin);
    });
}
function tags(o) {
    return new Map(Object.entries(o).map(([key, value]) => [key.toLowerCase(), '' + value]));
}

function escapeConcatFile(s) {
    return ('' + s).replace(/[\\' ]/g, (c) => `\\${c}`);
}
function escapeTeeComponent(s) {
    return ('' + s).replace(/[\\' |[\]]/g, (c) => `\\${c}`);
}
function escapeFilterComponent(s) {
    return ('' + s).replace(/[\\' [\],:;]/g, (c) => `\\${c}`);
}

function stringifySimpleFilterGraph(filter, options) {
    if (options === void 0)
        return filter;
    if (Array.isArray(options)) {
        if (options.length === 0)
            return filter;
        return `${filter}=${options.map(escapeFilterComponent).join(':')}`;
    }
    else {
        const entries = Object.entries(options);
        if (entries.length === 0)
            return filter;
        return `${filter}=${entries.map(([key, value]) => `${key}=${escapeFilterComponent(value)}`).join(':')}`;
    }
}

var _process, _exited, _error;
function spawn(args, ffmpegPath = getFFmpegPath()) {
    const process = spawn$1(ffmpegPath, args, { stdio: 'pipe' });
    return new Process(process, args, ffmpegPath);
}
class Process {
    constructor(process, args, ffmpegPath) {
        _process.set(this, void 0);
        _exited.set(this, false);
        _error.set(this, void 0);
        __classPrivateFieldSet(this, _process, process);
        this.args = args;
        this.ffmpegPath = ffmpegPath;
        const onExit = () => {
            __classPrivateFieldSet(this, _exited, true);
            process.off('exit', onExit);
            process.off('error', onExit);
        };
        process.on('exit', onExit);
        process.on('error', onExit);
    }
    async *progress() {
        let progress = {};
        for await (const line of createInterface(__classPrivateFieldGet(this, _process).stdout)) {
            try {
                const [key, rawValue] = line.split('=');
                const value = rawValue.trim();
                switch (key.trim()) {
                    case 'frame':
                        progress.frames = parseInt(value, 10) >>> 0;
                        break;
                    case 'fps':
                        progress.fps = parseFloat(value) || 0;
                        break;
                    case 'bitrate':
                        progress.bitrate = parseFloat(value) || 0;
                        break;
                    case 'total_size':
                        progress.bytes = parseInt(value, 10) >>> 0;
                        break;
                    case 'out_time_us':
                        progress.time = parseInt(value, 10) / 1000 >>> 0;
                        break;
                    case 'dup_frames':
                        progress.framesDuped = parseInt(value, 10) >>> 0;
                        break;
                    case 'drop_frames':
                        progress.framesDropped = parseInt(value, 10) >>> 0;
                        break;
                    case 'speed':
                        progress.speed = parseFloat(value) || 0;
                        break;
                    case 'progress':
                        yield progress;
                        if (value === 'end')
                            return;
                        progress = {};
                        break;
                }
            }
            catch (_a) {
            }
        }
    }
    async abort() {
        const stdin = __classPrivateFieldGet(this, _process).stdin;
        if (__classPrivateFieldGet(this, _exited) || !stdin.writable)
            throw new TypeError('Cannot abort FFmpeg process, stdin not writable');
        await write(stdin, new Uint8Array([113, 13, 10]));
        return await this.complete();
    }
    pause() {
        const process = __classPrivateFieldGet(this, _process);
        if (__classPrivateFieldGet(this, _exited))
            return false;
        return pause(process);
    }
    resume() {
        const process = __classPrivateFieldGet(this, _process);
        if (__classPrivateFieldGet(this, _exited))
            return false;
        return resume(process);
    }
    complete() {
        return new Promise((resolve, reject) => {
            const ffmpeg = __classPrivateFieldGet(this, _process);
            const error = async () => {
                if (!__classPrivateFieldGet(this, _error)) {
                    const stderr = ffmpeg.stderr.readable ? await fromAsyncIterable(createInterface(ffmpeg.stderr)) : [];
                    const message = extractMessage(stderr) || `FFmpeg exited with code ${ffmpeg.exitCode}`;
                    __classPrivateFieldSet(this, _error, new FFmpegError(message, stderr));
                }
                reject(__classPrivateFieldGet(this, _error));
            };
            const complete = () => ffmpeg.exitCode === 0 ? resolve() : error();
            if (__classPrivateFieldGet(this, _exited)) {
                complete();
            }
            else {
                const onExit = () => {
                    ffmpeg.off('exit', onExit);
                    ffmpeg.off('error', onExit);
                    complete();
                };
                ffmpeg.on('exit', onExit);
                ffmpeg.on('error', onExit);
            }
        });
    }
    unwrap() {
        return __classPrivateFieldGet(this, _process);
    }
    get pid() {
        return __classPrivateFieldGet(this, _process).pid;
    }
    kill(signal) {
        return __classPrivateFieldGet(this, _process).kill(signal);
    }
}
_process = new WeakMap(), _exited = new WeakMap(), _error = new WeakMap();

var _args, _inputs, _outputs, _inputStreams, _outputStreams, _url, _args_1, _stream, _url_1, _args_2, _videoFilters, _audioFilters;
var LogLevel;
(function (LogLevel) {
    LogLevel["Quiet"] = "quiet";
    LogLevel["Panic"] = "panic";
    LogLevel["Fatal"] = "fatal";
    LogLevel["Error"] = "error";
    LogLevel["Warning"] = "warning";
    LogLevel["Info"] = "info";
    LogLevel["Verbose"] = "verbose";
    LogLevel["Debug"] = "debug";
    LogLevel["Trace"] = "trace";
})(LogLevel || (LogLevel = {}));
function ffmpeg(options = {}) {
    return new Command(options);
}
class Command {
    constructor(options) {
        var _a;
        _args.set(this, []);
        _inputs.set(this, []);
        _outputs.set(this, []);
        _inputStreams.set(this, []);
        _outputStreams.set(this, []);
        this.logLevel = (_a = options.logLevel) !== null && _a !== void 0 ? _a : LogLevel.Error;
        this.args(options.overwrite !== false ? '-y' : '-n');
        if (options.progress !== false)
            this.args('-progress', 'pipe:1', '-nostats');
    }
    input(source) {
        const [url, isStream, stream] = handleSource(source, __classPrivateFieldGet(this, _inputStreams));
        const input = new Input(url, isStream, stream);
        __classPrivateFieldGet(this, _inputs).push(input);
        return input;
    }
    concat(sources, options = {}) {
        let directives = 'ffconcat version 1.0\n';
        const isInputSource = (o) => typeof o === 'string' || isReadableStream(o) ||
            o instanceof Uint8Array || Symbol.asyncIterator in o;
        const inputStreams = __classPrivateFieldGet(this, _inputStreams);
        const addFile = (file) => {
            const [url] = handleSource(file, inputStreams);
            directives += `file ${escapeConcatFile(url)}\n`;
        };
        sources.forEach((source) => {
            if (isInputSource(source)) {
                addFile(source);
            }
            else {
                if (source.file !== void 0)
                    addFile(source.file);
                if (source.duration !== void 0)
                    directives += `duration ${source.duration}ms\n`;
                if (source.inpoint !== void 0)
                    directives += `inpoint ${source.inpoint}ms\n`;
                if (source.outpoint !== void 0)
                    directives += `outpoint ${source.outpoint}ms\n`;
            }
        });
        const stream = Readable.from([Buffer.from(directives, 'utf8')], { objectMode: false });
        const path = getSocketPath();
        inputStreams.push([path, stream]);
        const input = new Input(getSocketUrl(path), true, stream);
        input.args('-safe', options.safe ? '1' : '0');
        if (options.protocols && options.protocols.length > 0)
            input.args('-protocol_whitelist', options.protocols.join(','));
        __classPrivateFieldGet(this, _inputs).push(input);
        return input;
    }
    output(...destinations) {
        let streams;
        let isStream = false;
        const urls = flatMap(destinations, (dest) => {
            if (typeof dest === 'string') {
                return dest;
            }
            if (!isStream) {
                isStream = true;
                streams = [dest];
                const path = getSocketPath();
                __classPrivateFieldGet(this, _outputStreams).push([path, streams]);
                return getSocketUrl(path);
            }
            streams.push(dest);
            return [];
        });
        const url = urls.length === 0 ? DEV_NULL
            : urls.length === 1 ? urls[0]
                : `tee:${urls.map(escapeTeeComponent).join('|')}`;
        const output = new Output(url, isStream);
        __classPrivateFieldGet(this, _outputs).push(output);
        return output;
    }
    args(...args) {
        __classPrivateFieldGet(this, _args).push(...args);
        return this;
    }
    async spawn(options = {}) {
        const { ffmpegPath = getFFmpegPath(), spawnOptions = {}, } = options;
        const args = this.getArgs();
        const [inputSocketServers, outputSocketServers] = await Promise.all([
            handleInputs(__classPrivateFieldGet(this, _inputStreams)),
            handleOutputs(__classPrivateFieldGet(this, _outputStreams)),
        ]);
        const ffmpeg = spawn$1(ffmpegPath, args, {
            stdio: 'pipe',
            ...spawnOptions,
        });
        const onExit = () => {
            const closeSocketServer = (server) => {
                if (server.listening)
                    server.close();
            };
            inputSocketServers.forEach(closeSocketServer);
            outputSocketServers.forEach(closeSocketServer);
            ffmpeg.off('exit', onExit);
            ffmpeg.off('error', onExit);
        };
        ffmpeg.on('exit', onExit);
        ffmpeg.on('error', onExit);
        return new Process(ffmpeg, args, ffmpegPath);
    }
    getArgs() {
        const inputs = __classPrivateFieldGet(this, _inputs);
        if (inputs.length < 1)
            throw new TypeError('At least one input file should be specified');
        const outputs = __classPrivateFieldGet(this, _outputs);
        if (outputs.length < 1)
            throw new TypeError('At least one output file should be specified');
        return [
            ...__classPrivateFieldGet(this, _args),
            '-v', this.logLevel.toString(),
            ...flatMap(inputs, (input) => input.getArgs()),
            ...flatMap(outputs, (output) => output.getArgs()),
        ];
    }
}
_args = new WeakMap(), _inputs = new WeakMap(), _outputs = new WeakMap(), _inputStreams = new WeakMap(), _outputStreams = new WeakMap();
class Input {
    constructor(url, isStream, stream) {
        _url.set(this, void 0);
        _args_1.set(this, []);
        _stream.set(this, void 0);
        __classPrivateFieldSet(this, _url, url);
        __classPrivateFieldSet(this, _stream, stream);
        this.isStream = isStream;
    }
    offset(offset) {
        return this.args('-itsoffset', `${offset}ms`);
    }
    duration(duration) {
        return this.args('-t', `${duration}ms`);
    }
    start(start) {
        return this.args('-ss', `${start}ms`);
    }
    format(format) {
        return this.args('-f', format);
    }
    codec(codec) {
        return this.args('-c', codec);
    }
    videoCodec(codec) {
        return this.args('-c:V', codec);
    }
    audioCodec(codec) {
        return this.args('-c:a', codec);
    }
    subtitleCodec(codec) {
        return this.args('-c:s', codec);
    }
    async probe(options = {}) {
        const readChunk = () => {
            var _a;
            const stream = __classPrivateFieldGet(this, _stream);
            const size = (_a = options.probeSize) !== null && _a !== void 0 ? _a : 5000000;
            return new Promise((resolve, reject) => {
                const unlisten = () => {
                    stream.off('readable', onReadable);
                    stream.off('error', onError);
                };
                const onError = (error) => {
                    unlisten();
                    reject(error);
                };
                const onReadable = () => {
                    const chunk = stream.read(size);
                    if (chunk !== null) {
                        unlisten();
                        stream.unshift(chunk);
                        resolve(chunk);
                    }
                };
                stream.on('readable', onReadable);
                stream.on('error', onError);
                stream.pause();
            });
        };
        const source = this.isStream ? await readChunk() : __classPrivateFieldGet(this, _url);
        return await probe(source, options);
    }
    getArgs() {
        return [
            ...__classPrivateFieldGet(this, _args_1),
            '-i',
            __classPrivateFieldGet(this, _url),
        ];
    }
    args(...args) {
        __classPrivateFieldGet(this, _args_1).push(...args);
        return this;
    }
}
_url = new WeakMap(), _args_1 = new WeakMap(), _stream = new WeakMap();
class Output {
    constructor(url, isStream) {
        _url_1.set(this, void 0);
        _args_2.set(this, []);
        _videoFilters.set(this, []);
        _audioFilters.set(this, []);
        __classPrivateFieldSet(this, _url_1, url);
        this.isStream = isStream;
    }
    videoFilter(filter, options) {
        __classPrivateFieldGet(this, _videoFilters).push(stringifySimpleFilterGraph(filter, options));
        return this;
    }
    audioFilter(filter, options) {
        __classPrivateFieldGet(this, _audioFilters).push(stringifySimpleFilterGraph(filter, options));
        return this;
    }
    metadata(metadata, specifier) {
        return this.args(...flatMap(Object.entries(metadata), ([key, value]) => [
            `-metadata${specifier ? ':' + specifier : ''}`,
            `${key}=${value}`,
        ]));
    }
    map(...streams) {
        return this.args(...flatMap(streams, (stream) => ['-map', stream]));
    }
    format(format) {
        return this.args('-f', format);
    }
    codec(codec) {
        return this.args('-c', codec);
    }
    videoCodec(codec) {
        return this.args('-c:V', codec);
    }
    audioCodec(codec) {
        return this.args('-c:a', codec);
    }
    subtitleCodec(codec) {
        return this.args('-c:s', codec);
    }
    duration(duration) {
        return this.args('-t', `${duration}ms`);
    }
    start(start) {
        return this.args('-ss', `${start}ms`);
    }
    args(...args) {
        __classPrivateFieldGet(this, _args_2).push(...args);
        return this;
    }
    getArgs() {
        const videoFilters = __classPrivateFieldGet(this, _videoFilters);
        const audioFilters = __classPrivateFieldGet(this, _audioFilters);
        return [
            ...__classPrivateFieldGet(this, _args_2),
            ...(videoFilters.length > 0 ? ['-filter:V', videoFilters.join(',')] : []),
            ...(audioFilters.length > 0 ? ['-filter:a', audioFilters.join(',')] : []),
            __classPrivateFieldGet(this, _url_1),
        ];
    }
}
_url_1 = new WeakMap(), _args_2 = new WeakMap(), _videoFilters = new WeakMap(), _audioFilters = new WeakMap();
function handleSource(source, streams) {
    if (typeof source === 'string') {
        return [source, false];
    }
    else {
        const path = getSocketPath();
        const stream = toReadable(source);
        streams.push([path, stream]);
        return [getSocketUrl(path), true, stream];
    }
}
function handleInputStream(server, stream) {
    server.once('connection', (socket) => {
        const onError = () => {
            if (socket.writable)
                socket.end();
            stream.off('error', onError);
            socket.off('error', onError);
        };
        stream.on('error', onError);
        socket.on('error', onError);
        stream.pipe(socket);
        server.close();
    });
}
function handleOutputStream(server, streams) {
    server.once('connection', (socket) => {
        const unlisten = () => {
            socket.off('error', onError);
            socket.off('data', onData);
            socket.off('end', onEnd);
        };
        const onError = () => {
            if (socket.writable)
                socket.end();
            unlisten();
        };
        const onData = (data) => {
            streams.forEach((stream) => stream.write(data));
        };
        const onEnd = () => {
            streams.forEach((stream) => stream.end());
            unlisten();
        };
        socket.on('error', onError);
        socket.on('data', onData);
        socket.on('end', onEnd);
        server.close();
    });
}
async function handleOutputs(outputStreams) {
    const servers = await Promise.all(outputStreams.map(([path]) => createSocketServer(path)));
    outputStreams.forEach(([, streams], i) => handleOutputStream(servers[i], streams));
    return servers;
}
async function handleInputs(inputStreams) {
    const servers = await Promise.all(inputStreams.map(([path]) => createSocketServer(path)));
    inputStreams.forEach(([, stream], i) => handleInputStream(servers[i], stream));
    return servers;
}

export { FFmpegError, FFprobeError, LogLevel, ffmpeg, getCodecs, getDecoders, getDemuxers, getEncoders, getFFmpegPath, getFFprobePath, getFilters, getFormats, getMuxers, getPixelFormats, getVersion, probe, setFFmpegPath, setFFprobePath, spawn };
