/// <reference types="node" />
import { ChildProcess } from 'child_process';
import { SpawnOptions as SpawnOptions_2 } from 'child_process';

/** @public */
export declare type AudioCodec = '4gv' | '8svx_exp' | '8svx_fib' | 'aac' | 'aac_latm' | 'ac3' | 'acelp.kelvin' | 'adpcm_4xm' | 'adpcm_adx' | 'adpcm_afc' | 'adpcm_agm' | 'adpcm_aica' | 'adpcm_argo' | 'adpcm_ct' | 'adpcm_dtk' | 'adpcm_ea' | 'adpcm_ea_maxis_xa' | 'adpcm_ea_r1' | 'adpcm_ea_r2' | 'adpcm_ea_r3' | 'adpcm_ea_xas' | 'adpcm_g722' | 'adpcm_g726' | 'adpcm_g726le' | 'adpcm_ima_alp' | 'adpcm_ima_amv' | 'adpcm_ima_apc' | 'adpcm_ima_apm' | 'adpcm_ima_cunning' | 'adpcm_ima_dat4' | 'adpcm_ima_dk3' | 'adpcm_ima_dk4' | 'adpcm_ima_ea_eacs' | 'adpcm_ima_ea_sead' | 'adpcm_ima_iss' | 'adpcm_ima_moflex' | 'adpcm_ima_mtf' | 'adpcm_ima_oki' | 'adpcm_ima_qt' | 'adpcm_ima_rad' | 'adpcm_ima_smjpeg' | 'adpcm_ima_ssi' | 'adpcm_ima_wav' | 'adpcm_ima_ws' | 'adpcm_ms' | 'adpcm_mtaf' | 'adpcm_psx' | 'adpcm_sbpro_2' | 'adpcm_sbpro_3' | 'adpcm_sbpro_4' | 'adpcm_swf' | 'adpcm_thp' | 'adpcm_thp_le' | 'adpcm_vima' | 'adpcm_xa' | 'adpcm_yamaha' | 'adpcm_zork' | 'alac' | 'amr_nb' | 'amr_wb' | 'ape' | 'aptx' | 'aptx_hd' | 'atrac1' | 'atrac3' | 'atrac3al' | 'atrac3p' | 'atrac3pal' | 'atrac9' | 'avc' | 'binkaudio_dct' | 'binkaudio_rdft' | 'bmv_audio' | 'celt' | 'codec2' | 'comfortnoise' | 'cook' | 'derf_dpcm' | 'dolby_e' | 'dsd_lsbf' | 'dsd_lsbf_planar' | 'dsd_msbf' | 'dsd_msbf_planar' | 'dsicinaudio' | 'dss_sp' | 'dst' | 'dts' | 'dvaudio' | 'eac3' | 'evrc' | 'fastaudio' | 'flac' | 'g723_1' | 'g729' | 'gremlin_dpcm' | 'gsm' | 'gsm_ms' | 'hca' | 'hcom' | 'iac' | 'ilbc' | 'imc' | 'interplay_dpcm' | 'interplayacm' | 'mace3' | 'mace6' | 'metasound' | 'mlp' | 'mp1' | 'mp2' | 'mp3' | 'mp3adu' | 'mp3on4' | 'mp4als' | 'mpegh_3d_audio' | 'musepack7' | 'musepack8' | 'nellymoser' | 'opus' | 'paf_audio' | 'pcm_alaw' | 'pcm_bluray' | 'pcm_dvd' | 'pcm_f16le' | 'pcm_f24le' | 'pcm_f32be' | 'pcm_f32le' | 'pcm_f64be' | 'pcm_f64le' | 'pcm_lxf' | 'pcm_mulaw' | 'pcm_s16be' | 'pcm_s16be_planar' | 'pcm_s16le' | 'pcm_s16le_planar' | 'pcm_s24be' | 'pcm_s24daud' | 'pcm_s24le' | 'pcm_s24le_planar' | 'pcm_s32be' | 'pcm_s32le' | 'pcm_s32le_planar' | 'pcm_s64be' | 'pcm_s64le' | 'pcm_s8' | 'pcm_s8_planar' | 'pcm_u16be' | 'pcm_u16le' | 'pcm_u24be' | 'pcm_u24le' | 'pcm_u32be' | 'pcm_u32le' | 'pcm_u8' | 'pcm_vidc' | 'qcelp' | 'qdm2' | 'qdmc' | 'ra_144' | 'ra_288' | 'ralf' | 'roq_dpcm' | 's302m' | 'sbc' | 'sdx2_dpcm' | 'shorten' | 'sipr' | 'siren' | 'smackaudio' | 'smv' | 'sol_dpcm' | 'sonic' | 'sonicls' | 'speex' | 'tak' | 'truehd' | 'truespeech' | 'tta' | 'twinvq' | 'vmdaudio' | 'vorbis' | 'wavesynth' | 'wavpack' | 'westwood_snd1' | 'wmalossless' | 'wmapro' | 'wmav1' | 'wmav2' | 'wmavoice' | 'xan_dpcm' | 'xma1' | 'xma2';

/** @public */
export declare type AudioDecoder = '8svx_exp' | '8svx_fib' | 'aac' | 'aac_fixed' | 'aac_latm' | 'ac3' | 'ac3_fixed' | 'acelp.kelvin' | 'adpcm_4xm' | 'adpcm_adx' | 'adpcm_afc' | 'adpcm_agm' | 'adpcm_aica' | 'adpcm_argo' | 'adpcm_ct' | 'adpcm_dtk' | 'adpcm_ea' | 'adpcm_ea_maxis_xa' | 'adpcm_ea_r1' | 'adpcm_ea_r2' | 'adpcm_ea_r3' | 'adpcm_ea_xas' | 'g722' | 'g726' | 'g726le' | 'adpcm_ima_alp' | 'adpcm_ima_amv' | 'adpcm_ima_apc' | 'adpcm_ima_apm' | 'adpcm_ima_cunning' | 'adpcm_ima_dat4' | 'adpcm_ima_dk3' | 'adpcm_ima_dk4' | 'adpcm_ima_ea_eacs' | 'adpcm_ima_ea_sead' | 'adpcm_ima_iss' | 'adpcm_ima_moflex' | 'adpcm_ima_mtf' | 'adpcm_ima_oki' | 'adpcm_ima_qt' | 'adpcm_ima_rad' | 'adpcm_ima_smjpeg' | 'adpcm_ima_ssi' | 'adpcm_ima_wav' | 'adpcm_ima_ws' | 'adpcm_ms' | 'adpcm_mtaf' | 'adpcm_psx' | 'adpcm_sbpro_2' | 'adpcm_sbpro_3' | 'adpcm_sbpro_4' | 'adpcm_swf' | 'adpcm_thp' | 'adpcm_thp_le' | 'adpcm_vima' | 'adpcm_xa' | 'adpcm_yamaha' | 'adpcm_zork' | 'alac' | 'amrnb' | 'libopencore_amrnb' | 'amrwb' | 'libopencore_amrwb' | 'ape' | 'aptx' | 'aptx_hd' | 'atrac1' | 'atrac3' | 'atrac3al' | 'atrac3plus' | 'atrac3plusal' | 'atrac9' | 'on2avc' | 'binkaudio_dct' | 'binkaudio_rdft' | 'bmv_audio' | 'comfortnoise' | 'cook' | 'derf_dpcm' | 'dolby_e' | 'dsd_lsbf' | 'dsd_lsbf_planar' | 'dsd_msbf' | 'dsd_msbf_planar' | 'dsicinaudio' | 'dss_sp' | 'dst' | 'dca' | 'dvaudio' | 'eac3' | 'evrc' | 'fastaudio' | 'flac' | 'g723_1' | 'g729' | 'gremlin_dpcm' | 'gsm' | 'gsm_ms' | 'hca' | 'hcom' | 'iac' | 'ilbc' | 'imc' | 'interplay_dpcm' | 'interplayacm' | 'mace3' | 'mace6' | 'metasound' | 'mlp' | 'mp1' | 'mp1float' | 'mp2' | 'mp2float' | 'mp3float' | 'mp3' | 'mp3adufloat' | 'mp3adu' | 'mp3on4float' | 'mp3on4' | 'als' | 'mpc7' | 'mpc8' | 'nellymoser' | 'opus' | 'libopus' | 'paf_audio' | 'pcm_alaw' | 'pcm_bluray' | 'pcm_dvd' | 'pcm_f16le' | 'pcm_f24le' | 'pcm_f32be' | 'pcm_f32le' | 'pcm_f64be' | 'pcm_f64le' | 'pcm_lxf' | 'pcm_mulaw' | 'pcm_s16be' | 'pcm_s16be_planar' | 'pcm_s16le' | 'pcm_s16le_planar' | 'pcm_s24be' | 'pcm_s24daud' | 'pcm_s24le' | 'pcm_s24le_planar' | 'pcm_s32be' | 'pcm_s32le' | 'pcm_s32le_planar' | 'pcm_s64be' | 'pcm_s64le' | 'pcm_s8' | 'pcm_s8_planar' | 'pcm_u16be' | 'pcm_u16le' | 'pcm_u24be' | 'pcm_u24le' | 'pcm_u32be' | 'pcm_u32le' | 'pcm_u8' | 'pcm_vidc' | 'qcelp' | 'qdm2' | 'qdmc' | 'real_144' | 'real_288' | 'ralf' | 'roq_dpcm' | 's302m' | 'sbc' | 'sdx2_dpcm' | 'shorten' | 'sipr' | 'siren' | 'smackaud' | 'sol_dpcm' | 'sonic' | 'tak' | 'truehd' | 'truespeech' | 'tta' | 'twinvq' | 'vmdaudio' | 'vorbis' | 'libvorbis' | 'wavesynth' | 'wavpack' | 'ws_snd1' | 'wmalossless' | 'wmapro' | 'wmav1' | 'wmav2' | 'wmavoice' | 'xan_dpcm' | 'xma1' | 'xma2';

/** @public */
export declare type AudioEncoder = 'aac' | 'aac_mf' | 'ac3' | 'ac3_fixed' | 'ac3_mf' | 'adpcm_adx' | 'adpcm_argo' | 'g722' | 'g726' | 'g726le' | 'adpcm_ima_apm' | 'adpcm_ima_qt' | 'adpcm_ima_ssi' | 'adpcm_ima_wav' | 'adpcm_ms' | 'adpcm_swf' | 'adpcm_yamaha' | 'alac' | 'libopencore_amrnb' | 'aptx' | 'aptx_hd' | 'comfortnoise' | 'dca' | 'eac3' | 'flac' | 'g723_1' | 'mlp' | 'mp2' | 'mp2fixed' | 'libtwolame' | 'libmp3lame' | 'mp3_mf' | 'nellymoser' | 'opus' | 'libopus' | 'pcm_alaw' | 'pcm_dvd' | 'pcm_f32be' | 'pcm_f32le' | 'pcm_f64be' | 'pcm_f64le' | 'pcm_mulaw' | 'pcm_s16be' | 'pcm_s16be_planar' | 'pcm_s16le' | 'pcm_s16le_planar' | 'pcm_s24be' | 'pcm_s24daud' | 'pcm_s24le' | 'pcm_s24le_planar' | 'pcm_s32be' | 'pcm_s32le' | 'pcm_s32le_planar' | 'pcm_s64be' | 'pcm_s64le' | 'pcm_s8' | 'pcm_s8_planar' | 'pcm_u16be' | 'pcm_u16le' | 'pcm_u24be' | 'pcm_u24le' | 'pcm_u32be' | 'pcm_u32le' | 'pcm_u8' | 'pcm_vidc' | 'real_144' | 'roq_dpcm' | 's302m' | 'sbc' | 'sonic' | 'sonicls' | 'truehd' | 'tta' | 'vorbis' | 'libvorbis' | 'wavpack' | 'wmav1' | 'wmav2';

/** @public */
export declare type AudioFilter = 'abench' | 'acompressor' | 'acontrast' | 'acopy' | 'acue' | 'acrossfade' | 'acrossover' | 'acrusher' | 'adeclick' | 'adeclip' | 'adelay' | 'aderivative' | 'aecho' | 'aemphasis' | 'aeval' | 'afade' | 'afftdn' | 'afftfilt' | 'aformat' | 'agate' | 'aiir' | 'aintegral' | 'alimiter' | 'allpass' | 'aloop' | 'ametadata' | 'amultiply' | 'anequalizer' | 'anlmdn' | 'anlms' | 'anull' | 'apad' | 'aperms' | 'aphaser' | 'apulsator' | 'arealtime' | 'aresample' | 'areverse' | 'arnndn' | 'aselect' | 'asendcmd' | 'asetnsamples' | 'asetpts' | 'asetrate' | 'asettb' | 'ashowinfo' | 'asidedata' | 'asoftclip' | 'asplit' | 'astats' | 'asubboost' | 'atempo' | 'atrim' | 'axcorrelate' | 'bandpass' | 'bandreject' | 'bass' | 'biquad' | 'channelmap' | 'channelsplit' | 'chorus' | 'compand' | 'compensationdelay' | 'crossfeed' | 'crystalizer' | 'dcshift' | 'deesser' | 'drmeter' | 'dynaudnorm' | 'earwax' | 'ebur128' | 'equalizer' | 'extrastereo' | 'firequalizer' | 'flanger' | 'haas' | 'hdcd' | 'highpass' | 'highshelf' | 'loudnorm' | 'lowpass' | 'lowshelf' | 'mcompand' | 'pan' | 'replaygain' | 'sidechaincompress' | 'sidechaingate' | 'silencedetect' | 'silenceremove' | 'stereotools' | 'stereowiden' | 'superequalizer' | 'surround' | 'treble' | 'tremolo' | 'vibrato' | 'volume' | 'volumedetect' | 'anullsink' | 'abitscope' | 'adrawgraph' | 'agraphmonitor' | 'ahistogram' | 'aphasemeter' | 'avectorscope' | 'showcqt' | 'showfreqs' | 'showspatial' | 'showspectrum' | 'showspectrumpic' | 'showvolume' | 'showwaves' | 'showwavespic' | 'afifo' | 'abuffersink';

/** @public */
export declare type ChannelLayout = 'mono' | 'stereo' | '2.1' | '3.0' | '3.0(back)' | '4.0' | 'quad' | 'quad(side)' | '3.1' | '5.0' | '5.0(side)' | '4.1' | '5.1' | '5.1(side)' | '6.0' | '6.0(front)' | 'hexagonal' | '6.1' | '6.1(back)' | '6.1(front)' | '7.0' | '7.0(front)' | '7.1' | '7.1(wide)' | '7.1(wide-side)' | 'octagonal' | 'hexadecagonal' | 'downmix';

/** @public */
export declare type ChromaLocation = 'left' | 'center' | 'topleft' | 'top' | 'bottomleft' | 'bottom';

/** @public */
export declare interface Codecs {
    video: Set<string>;
    audio: Set<string>;
    subtitle: Set<string>;
    data: Set<string>;
}

/** @public */
export declare type ColorRange = 'limited' | 'tv' | 'mpeg' | 'full' | 'pc' | 'jpeg';

/** @public */
export declare type ColorSpace = 'gbr' | 'bt709' | 'fcc' | 'bt470bg' | 'smpte170m' | 'smpte240m' | 'ycgco' | 'bt2020nc' | 'bt2020c' | 'smpte2085' | 'chroma-derived-nc' | 'chroma-derived-c' | 'ictcp';

/** @alpha */
export declare interface ConcatOptions {
    safe?: boolean;
    protocols?: string[];
}

/** @alpha */
export declare type ConcatSource = InputSource | {
    file?: InputSource;
    duration?: number;
    inpoint?: number;
    outpoint?: number;
};

/** @public */
export declare type DataCodec = 'bin_data' | 'dvd_nav_packet' | 'epg' | 'klv' | 'otf' | 'scte_35' | 'timed_id3' | 'ttf';

/** @public */
export declare type Demuxer = '3dostr' | '4xm' | 'aa' | 'aac' | 'aax' | 'ac3' | 'acm' | 'act' | 'adf' | 'adp' | 'ads' | 'adx' | 'aea' | 'afc' | 'aiff' | 'aix' | 'alaw' | 'alias_pix' | 'alp' | 'amr' | 'amrnb' | 'amrwb' | 'anm' | 'apc' | 'ape' | 'apm' | 'apng' | 'aptx' | 'aptx_hd' | 'aqtitle' | 'argo_asf' | 'argo_brp' | 'asf' | 'asf_o' | 'ass' | 'ast' | 'au' | 'av1' | 'avi' | 'avisynth' | 'avr' | 'avs' | 'avs2' | 'bethsoftvid' | 'bfi' | 'bfstm' | 'bin' | 'bink' | 'bit' | 'bmp_pipe' | 'bmv' | 'boa' | 'brender_pix' | 'brstm' | 'c93' | 'caf' | 'cavsvideo' | 'cdg' | 'cdxl' | 'cine' | 'codec2' | 'codec2raw' | 'concat' | 'dash' | 'data' | 'daud' | 'dcstr' | 'dds_pipe' | 'derf' | 'dfa' | 'dhav' | 'dirac' | 'dnxhd' | 'dpx_pipe' | 'dsf' | 'dshow' | 'dsicin' | 'dss' | 'dts' | 'dtshd' | 'dv' | 'dvbsub' | 'dvbtxt' | 'dxa' | 'ea' | 'ea_cdata' | 'eac3' | 'epaf' | 'exr_pipe' | 'f32be' | 'f32le' | 'f64be' | 'f64le' | 'ffmetadata' | 'film_cpk' | 'filmstrip' | 'fits' | 'flac' | 'flic' | 'flv' | 'frm' | 'fsb' | 'fwse' | 'g722' | 'g723_1' | 'g726' | 'g726le' | 'g729' | 'gdigrab' | 'gdv' | 'genh' | 'gif' | 'gif_pipe' | 'gsm' | 'gxf' | 'h261' | 'h263' | 'h264' | 'hca' | 'hcom' | 'hevc' | 'hls' | 'hnm' | 'ico' | 'idcin' | 'idf' | 'iff' | 'ifv' | 'ilbc' | 'image2' | 'image2pipe' | 'ingenient' | 'ipmovie' | 'ipu' | 'ircam' | 'iss' | 'iv8' | 'ivf' | 'ivr' | 'j2k_pipe' | 'jacosub' | 'jpeg_pipe' | 'jpegls_pipe' | 'jv' | 'kux' | 'kvag' | 'lavfi' | 'live_flv' | 'lmlm4' | 'loas' | 'lrc' | 'luodat' | 'lvf' | 'lxf' | 'm4v' | 'matroska,webm' | 'mca' | 'mcc' | 'mgsts' | 'microdvd' | 'mjpeg' | 'mjpeg_2000' | 'mlp' | 'mlv' | 'mm' | 'mmf' | 'mods' | 'moflex' | 'mov,mp4,m4a,3gp,3g2,mj2' | 'mp3' | 'mpc' | 'mpc8' | 'mpeg' | 'mpegts' | 'mpegtsraw' | 'mpegvideo' | 'mpjpeg' | 'mpl2' | 'mpsub' | 'msf' | 'msnwctcp' | 'mtaf' | 'mtv' | 'mulaw' | 'musx' | 'mv' | 'mvi' | 'mxf' | 'mxg' | 'nc' | 'nistsphere' | 'nsp' | 'nsv' | 'nut' | 'nuv' | 'obu' | 'ogg' | 'oma' | 'paf' | 'pam_pipe' | 'pbm_pipe' | 'pcx_pipe' | 'pgm_pipe' | 'pgmyuv_pipe' | 'pgx_pipe' | 'photocd_pipe' | 'pictor_pipe' | 'pjs' | 'pmp' | 'png_pipe' | 'pp_bnk' | 'ppm_pipe' | 'psd_pipe' | 'psxstr' | 'pva' | 'pvf' | 'qcp' | 'qdraw_pipe' | 'r3d' | 'rawvideo' | 'realtext' | 'redspark' | 'rl2' | 'rm' | 'roq' | 'rpl' | 'rsd' | 'rso' | 'rtp' | 'rtsp' | 's16be' | 's16le' | 's24be' | 's24le' | 's32be' | 's32le' | 's337m' | 's8' | 'sami' | 'sap' | 'sbc' | 'sbg' | 'scc' | 'sdp' | 'sdr2' | 'sds' | 'sdx' | 'ser' | 'sgi_pipe' | 'shn' | 'siff' | 'sln' | 'smjpeg' | 'smk' | 'smush' | 'sol' | 'sox' | 'spdif' | 'srt' | 'stl' | 'subviewer' | 'subviewer1' | 'sunrast_pipe' | 'sup' | 'svag' | 'svg_pipe' | 'svs' | 'swf' | 'tak' | 'tedcaptions' | 'thp' | 'tiertexseq' | 'tiff_pipe' | 'tmv' | 'truehd' | 'tta' | 'tty' | 'txd' | 'ty' | 'u16be' | 'u16le' | 'u24be' | 'u24le' | 'u32be' | 'u32le' | 'u8' | 'v210' | 'v210x' | 'vag' | 'vc1' | 'vc1test' | 'vfwcap' | 'vidc' | 'vividas' | 'vivo' | 'vmd' | 'vobsub' | 'voc' | 'vpk' | 'vplayer' | 'vqf' | 'w64' | 'wav' | 'wc3movie' | 'webm_dash_manifest' | 'webp_pipe' | 'webvtt' | 'wsaud' | 'wsd' | 'wsvqa' | 'wtv' | 'wv' | 'wve' | 'xa' | 'xbin' | 'xmv' | 'xpm_pipe' | 'xvag' | 'xwd_pipe' | 'xwma' | 'yop' | 'yuv4mpegpipe';

/**
 * Create a new FFmpegCommand.
 * @param options -
 * @public
 */
export declare function ffmpeg(options?: FFmpegOptions): FFmpegCommand;

/** @public */
export declare interface FFmpegCommand {
    /**
     * **UNSTABLE**: Under consideration for removal.
     *
     * The log level that will be used for the command. Set it using {@link FFmpegOptions}.
     * @alpha
     */
    readonly logLevel: LogLevel;
    /**
     * Adds an input to the conversion.
     * @param source -
     * @example
     * ```ts
     * const cmd = ffmpeg();
     * cmd.input('input.avi');
     * cmd.input(fs.createReadStream('input2.avi'));
     * cmd.output();
     * const process = await cmd.spawn();
     * await process.complete();
     * ```
     */
    input(source: InputSource): FFmpegInput;
    /**
     * **UNSTABLE:** New API, see https://github.com/FedericoCarboni/eloquent-ffmpeg/issues/2
     *
     * Concatenate media files using the `concat` demuxer.
     *
     * @param sources - The input sources to be concatenated, they can be in different formats but
     * they must have the same streams, codecs, timebases, etc...
     * {@link https://ffmpeg.org/ffmpeg-formats.html#concat-1}
     * {@link https://trac.ffmpeg.org/wiki/Concatenate}
     * @example
     * ```ts
     * const cmd = ffmpeg();
     * cmd.concat(['chunk1.webm', 'chunk2.webm']);
     * cmd.output('complete_video.webm');
     * const process = await cmd.spawn();
     * await process.complete();
     * ```
     * @alpha
     */
    concat(sources: ConcatSource[], options?: ConcatOptions): FFmpegInput;
    /**
     * Adds an output to the conversion, multiple destinations are supported using
     * the `tee` protocol. You can use mixed destinations and multiple streams.
     * Both NodeJS WritableStreams and AsyncGenerators are fully supported.
     * @param destinations - A sequence of OutputDestinations to which the output
     * will be written. If no destinations are specified the conversion will run,
     * but any output data will be ignored.
     * @example
     * ```ts
     * const cmd = ffmpeg();
     * cmd.input('input.avi');
     * cmd.output(fs.createWriteStream('dest1.mkv'), 'dest2.mkv');
     * const process = await cmd.spawn();
     * await process.complete();
     * ```
     */
    output(...destinations: OutputDestination[]): FFmpegOutput;
    /**
     * Add arguments, they will be placed before any input or output arguments.
     * @param args -
     */
    args(...args: string[]): this;
    /**
     * Starts the conversion, this method is asynchronous so it must be `await`'ed.
     * @param ffmpegPath - Path to the ffmpeg executable. Defaults to `getFFmpegPath()`.
     * @example
     * ```ts
     * const cmd = ffmpeg();
     * cmd.input('input.avi');
     * cmd.output('output.mp4');
     * const process = await cmd.spawn();
     * ```
     */
    spawn(options?: SpawnOptions): Promise<FFmpegProcess>;
    /**
     * Returns all the arguments with which ffmpeg will be spawned.
     */
    getArgs(): string[];
}

/**
 * Thrown when FFmpeg exits with a non-zero status code.
 * @public
 */
export declare class FFmpegError extends Error {
    stderr: readonly string[];
    constructor(message: string, stderr: readonly string[]);
}

/** @public */
export declare interface FFmpegInput {
    /**
     * **UNSTABLE**: Breaking changes are being considered, implementation details can change without
     * notice.
     *
     * Get information about the input, this is especially helpful when working
     * with streams. If the source is a stream `options.probeSize` number of bytes
     * will be read and passed to ffprobe; those bytes will be kept in memory
     * until the input is used in conversion.
     *
     * **Note:** This is not recommended for `concat()` inputs, because it may not
     * have effect you may expect. When using `concat()` inputs with streams, the
     * streams will be consumed.
     *
     * @param options -
     * @example
     * ```ts
     * const cmd = ffmpeg();
     * cmd.output('output.mp4');
     * const input = cmd.input(fs.createReadStream('input.mkv'));
     * const info = await input.probe();
     * console.log(`Video duration: ${info.duration}, format: ${info.format}`);
     * const process = await cmd.spawn();
     * await process.complete();
     * ```
     * @alpha
     */
    probe(options?: ProbeOptions): Promise<ProbeResult>;
    /**
     * Add input arguments, they will be placed before any additional arguments.
     * @param args -
     */
    args(...args: string[]): this;
    /**
     * Select the input format.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param format -
     */
    format(format: Format | Demuxer | (string & {})): this;
    /**
     * Select the codec for all streams.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param codec -
     */
    codec(codec: VideoCodec | VideoDecoder | AudioCodec | AudioDecoder | SubtitleCodec | SubtitleDecoder | (string & {})): this;
    /**
     * Select the codec for video streams.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param codec -
     */
    videoCodec(codec: VideoCodec | VideoDecoder | (string & {})): this;
    /**
     * Select the codec for audio streams.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param codec -
     */
    audioCodec(codec: AudioCodec | AudioDecoder | (string & {})): this;
    /**
     * Select the codec for subtitle streams.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param codec -
     */
    subtitleCodec(codec: SubtitleCodec | SubtitleDecoder | (string & {})): this;
    /**
     * Limit the duration of the data read from the input.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param duration - The limit for the duration in milliseconds.
     */
    duration(duration: number): this;
    /**
     * Seeks in the input file to `start`.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param start - The position to seek to in milliseconds.
     */
    start(start: number): this;
    /**
     * Adds `offset` to the input timestamps.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param offset - The offset in milliseconds. MAY be negative.
     */
    offset(offset: number): this;
    /**
     * Returns all the arguments for the input.
     */
    getArgs(): string[];
    /**
     * Whether the input is using streams.
     */
    readonly isStream: boolean;
}

/** @public */
export declare interface FFmpegOptions {
    /**
     * **UNSTABLE**: Support for logging is under consideration.
     *
     * Change FFmpeg's LogLevel, defaults to `LogLevel.Error`.
     * @alpha
     */
    logLevel?: LogLevel;
    /**
     * Enable piping the conversion progress, if set to `false` {@link FFmpegProcess.progress}
     * will silently fail. Defaults to `true`.
     */
    progress?: boolean;
    /**
     * Whether to overwrite the output destinations if they already exist. Required
     * to be `true` for streaming outputs. Defaults to `true`.
     */
    overwrite?: boolean;
}

/** @public */
export declare interface FFmpegOutput {
    /**
     * Add output arguments, they will be placed before any additional arguments.
     * @param args -
     */
    args(...args: string[]): this;
    /**
     * Select the output format.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param format -
     */
    format(format: Format | Muxer | (string & {})): this;
    /**
     * Select the codec for all streams.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param codec -
     */
    codec(codec: VideoCodec | VideoEncoder | AudioCodec | AudioEncoder | SubtitleCodec | SubtitleEncoder | (string & {})): this;
    /**
     * Select the codec for video streams.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param codec -
     */
    videoCodec(codec: VideoCodec | VideoEncoder | (string & {})): this;
    /**
     * Select the codec for audio streams.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param codec -
     */
    audioCodec(codec: AudioCodec | AudioEncoder | (string & {})): this;
    /**
     * Select the codec for subtitle streams.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param codec -
     */
    subtitleCodec(codec: SubtitleCodec | SubtitleEncoder | (string & {})): this;
    /**
     * **UNSTABLE**
     *
     * Applies a filter to the video streams.
     * @param filter - The filter to apply.
     * @param options - Additional configuration for the filter.
     */
    videoFilter(filter: VideoFilter | (string & {}), options?: Record<string, any> | any[]): this;
    /**
     * **UNSTABLE**
     *
     * Applies a filter to the video streams.
     * @param filter - The filter to apply.
     * @param options - Additional configuration for the filter.
     */
    audioFilter(filter: AudioFilter | (string & {}), options?: Record<string, any> | any[]): this;
    /**
     * Limit the duration of the data written to the output.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param duration - The limit for the duration in milliseconds.
     */
    duration(duration: number): this;
    /**
     * Decodes but discards the input until `start` is reached.
     * See {@link https://ffmpeg.org/ffmpeg-all.html#Main-options}
     * @param start - The number of milliseconds to discard.
     */
    start(start: number): this;
    /**
     * Maps inputs' streams to output streams. This is an advanced option.
     * {@link https://ffmpeg.org/ffmpeg-all.html#Advanced-options}
     * {@link https://ffmpeg.org/ffmpeg-all.html#Stream-specifiers-1}
     * {@link https://ffmpeg.org/ffmpeg-all.html#Automatic-stream-selection}
     * @param stream - The stream specifier.
     * @example
     * ```ts
     * const cmd = ffmpeg();
     * cmd.input('input0.mkv');
     * cmd.input('input1.avi');
     * cmd.output('output0.webm')
     * // Takes input0's video streams and input1's audio streams.
     *   .map('0:v', '1:a');
     * cmd.output('output1.webm')
     * // Streams will be mapped in the order they were specified
     * // here output1's first stream will be input0's second stream
     * // and its second stream will be input1's first stream.
     *   .map('0:1', '1:0');
     * ```
     */
    map(...streams: string[]): this;
    /**
     * Add metadata to a stream or an output.
     * {@link https://ffmpeg.org/ffmpeg.html#Main-options}
     * @param metadata - The metadata to add to the stream.
     * @param specifier - The stream to add metadata to, if not given `metadata`
     * will be added to the output file.
     */
    metadata(metadata: Record<string, string>, specifier?: string): this;
    /**
     * Returns all the arguments for the output.
     */
    getArgs(): string[];
    /**
     * Whether the output is using streams.
     */
    readonly isStream: boolean;
}

/** @public */
export declare interface FFmpegProcess {
    /**
     * **UNSTABLE:** Deprecated, not for use in new projects.
     *
     * @deprecated Use `FFmpegProcess.unwrap().pid` instead.
     *
     * Returns the process identifier (PID) of the process.
     */
    readonly pid: number;
    /**
     * The command line arguments used to spawn the process.
     */
    readonly args: readonly string[];
    /**
     * Path of the running ffmpeg executable.
     */
    readonly ffmpegPath: string;
    /**
     * Returns an AsyncGenerator representing the real-time progress of the conversion.
     * @example
     * ```ts
     * const process = await cmd.spawn();
     * for await (const progress of process.progress()) {
     *   console.log('Speed:', progress.speed);
     * }
     * ```
     * Using NodeJS Streams:
     * ```ts
     * const process = await cmd.spawn();
     * const progressStream = Readable.from(process.progress());
     * progressStream.on('data', (progress) => {
     *   console.log('Speed:', progress.speed);
     * });
     * ```
     */
    progress(): AsyncGenerator<Progress, void, void>;
    /**
     * Returns a Promise which resolves when the process exits, or rejects when the
     * process exits with a non-zero status code.
     * @example
     * ```ts
     * const process = cmd.spawn();
     * await process.complete();
     * console.log('Conversion complete!');
     * ```
     * To handle errors:
     * ```ts
     * const process = await cmd.spawn();
     * try {
     *   await process.complete();
     *   console.log('Conversion complete!');
     * } catch (e) {
     *   console.error('Conversion failed!', error);
     * }
     * ```
     */
    complete(): Promise<void>;
    /**
     * Aborts the conversion allowing FFmpeg to finish the generated files correctly.
     * This waits for FFmpeg to exit but doesn't wait guarantee that FFmpeg will succeed,
     * you should handle any possible errors.
     */
    abort(): Promise<void>;
    /**
     * Returns the underlying NodeJS' ChildProcess instance.
     */
    unwrap(): ChildProcess;
    /**
     * **UNSTABLE**: Deprecated, not for use in new projects.
     *
     * Sends a signal to the running process.
     * See {@link https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal}
     *
     * @deprecated To terminate the conversion use {@link FFmpegProcess.abort}, to pause and resume
     * the process use {@link FFmpegProcess.pause} or {@link FFmpegProcess.resume}. If you really
     * have to send a signal to the process use `process.unwrap().kill(signal)`.
     *
     * @param signal - The signal to send.
     */
    kill(signal?: NodeJS.Signals | number): boolean;
    /**
     * Pauses the conversion, returns `true` if the operation succeeds, `false` otherwise.
     */
    pause(): boolean;
    /**
     * Resumes the conversion, returns `true` if the operation succeeds, `false` otherwise.
     */
    resume(): boolean;
}

/**
 * Thrown when FFprobe exits with a non-zero status code.
 * @public
 */
export declare class FFprobeError extends Error {
    stderr: readonly string[];
    code?: number | undefined;
    constructor(message: string, stderr: readonly string[], code?: number | undefined);
}

/** @public */
export declare type FieldOrder = 'progressive' | 'tt' | 'bb' | 'tb' | 'bt';

/** @public */
export declare interface Filters {
    video: Set<string>;
    audio: Set<string>;
}

/** @public */
export declare type Format = '3dostr' | '3g2' | '3gp' | '4xm' | 'a64' | 'aa' | 'aac' | 'aax' | 'ac3' | 'acm' | 'act' | 'adf' | 'adp' | 'ads' | 'adts' | 'adx' | 'aea' | 'afc' | 'aiff' | 'aix' | 'alaw' | 'alias_pix' | 'alp' | 'amr' | 'amrnb' | 'amrwb' | 'anm' | 'apc' | 'ape' | 'apm' | 'apng' | 'aptx' | 'aptx_hd' | 'aqtitle' | 'argo_asf' | 'argo_brp' | 'asf' | 'asf_o' | 'asf_stream' | 'ass' | 'ast' | 'au' | 'av1' | 'avi' | 'avisynth' | 'avm2' | 'avr' | 'avs' | 'avs2' | 'bethsoftvid' | 'bfi' | 'bfstm' | 'bin' | 'bink' | 'bit' | 'bmp_pipe' | 'bmv' | 'boa' | 'brender_pix' | 'brstm' | 'c93' | 'caf' | 'cavsvideo' | 'cdg' | 'cdxl' | 'cine' | 'codec2' | 'codec2raw' | 'concat' | 'crc' | 'dash' | 'data' | 'daud' | 'dcstr' | 'dds_pipe' | 'derf' | 'dfa' | 'dhav' | 'dirac' | 'dnxhd' | 'dpx_pipe' | 'dsf' | 'dshow' | 'dsicin' | 'dss' | 'dts' | 'dtshd' | 'dv' | 'dvbsub' | 'dvbtxt' | 'dvd' | 'dxa' | 'ea' | 'ea_cdata' | 'eac3' | 'epaf' | 'exr_pipe' | 'f32be' | 'f32le' | 'f4v' | 'f64be' | 'f64le' | 'ffmetadata' | 'fifo' | 'fifo_test' | 'film_cpk' | 'filmstrip' | 'fits' | 'flac' | 'flic' | 'flv' | 'framecrc' | 'framehash' | 'framemd5' | 'frm' | 'fsb' | 'fwse' | 'g722' | 'g723_1' | 'g726' | 'g726le' | 'g729' | 'gdigrab' | 'gdv' | 'genh' | 'gif' | 'gif_pipe' | 'gsm' | 'gxf' | 'h261' | 'h263' | 'h264' | 'hash' | 'hca' | 'hcom' | 'hds' | 'hevc' | 'hls' | 'hnm' | 'ico' | 'idcin' | 'idf' | 'iff' | 'ifv' | 'ilbc' | 'image2' | 'image2pipe' | 'ingenient' | 'ipmovie' | 'ipod' | 'ipu' | 'ircam' | 'ismv' | 'iss' | 'iv8' | 'ivf' | 'ivr' | 'j2k_pipe' | 'jacosub' | 'jpeg_pipe' | 'jpegls_pipe' | 'jv' | 'kux' | 'kvag' | 'latm' | 'lavfi' | 'live_flv' | 'lmlm4' | 'loas' | 'lrc' | 'luodat' | 'lvf' | 'lxf' | 'm4v' | 'matroska' | 'matroska,webm' | 'mca' | 'mcc' | 'md5' | 'mgsts' | 'microdvd' | 'mjpeg' | 'mjpeg_2000' | 'mkvtimestamp_v2' | 'mlp' | 'mlv' | 'mm' | 'mmf' | 'mods' | 'moflex' | 'mov' | 'mov,mp4,m4a,3gp,3g2,mj2' | 'mp2' | 'mp3' | 'mp4' | 'mpc' | 'mpc8' | 'mpeg' | 'mpeg1video' | 'mpeg2video' | 'mpegts' | 'mpegtsraw' | 'mpegvideo' | 'mpjpeg' | 'mpl2' | 'mpsub' | 'msf' | 'msnwctcp' | 'mtaf' | 'mtv' | 'mulaw' | 'musx' | 'mv' | 'mvi' | 'mxf' | 'mxf_d10' | 'mxf_opatom' | 'mxg' | 'nc' | 'nistsphere' | 'nsp' | 'nsv' | 'null' | 'nut' | 'nuv' | 'obu' | 'oga' | 'ogg' | 'ogv' | 'oma' | 'opus' | 'paf' | 'pam_pipe' | 'pbm_pipe' | 'pcx_pipe' | 'pgm_pipe' | 'pgmyuv_pipe' | 'pgx_pipe' | 'photocd_pipe' | 'pictor_pipe' | 'pjs' | 'pmp' | 'png_pipe' | 'pp_bnk' | 'ppm_pipe' | 'psd_pipe' | 'psp' | 'psxstr' | 'pva' | 'pvf' | 'qcp' | 'qdraw_pipe' | 'r3d' | 'rawvideo' | 'realtext' | 'redspark' | 'rl2' | 'rm' | 'roq' | 'rpl' | 'rsd' | 'rso' | 'rtp' | 'rtp_mpegts' | 'rtsp' | 's16be' | 's16le' | 's24be' | 's24le' | 's32be' | 's32le' | 's337m' | 's8' | 'sami' | 'sap' | 'sbc' | 'sbg' | 'scc' | 'sdl,sdl2' | 'sdp' | 'sdr2' | 'sds' | 'sdx' | 'segment' | 'ser' | 'sgi_pipe' | 'shn' | 'siff' | 'singlejpeg' | 'sln' | 'smjpeg' | 'smk' | 'smoothstreaming' | 'smush' | 'sol' | 'sox' | 'spdif' | 'spx' | 'srt' | 'stl' | 'stream_segment,ssegment' | 'streamhash' | 'subviewer' | 'subviewer1' | 'sunrast_pipe' | 'sup' | 'svag' | 'svcd' | 'svg_pipe' | 'svs' | 'swf' | 'tak' | 'tedcaptions' | 'tee' | 'thp' | 'tiertexseq' | 'tiff_pipe' | 'tmv' | 'truehd' | 'tta' | 'tty' | 'txd' | 'ty' | 'u16be' | 'u16le' | 'u24be' | 'u24le' | 'u32be' | 'u32le' | 'u8' | 'uncodedframecrc' | 'v210' | 'v210x' | 'vag' | 'vc1' | 'vc1test' | 'vcd' | 'vfwcap' | 'vidc' | 'vividas' | 'vivo' | 'vmd' | 'vob' | 'vobsub' | 'voc' | 'vpk' | 'vplayer' | 'vqf' | 'w64' | 'wav' | 'wc3movie' | 'webm' | 'webm_chunk' | 'webm_dash_manifest' | 'webp' | 'webp_pipe' | 'webvtt' | 'wsaud' | 'wsd' | 'wsvqa' | 'wtv' | 'wv' | 'wve' | 'xa' | 'xbin' | 'xmv' | 'xpm_pipe' | 'xvag' | 'xwd_pipe' | 'xwma' | 'yop' | 'yuv4mpegpipe';

/**
 * Runs `ffmpeg -codecs` and returns its output as {@link Codecs}. This is generally not
 * very useful, if you need to check the compatibility for a certain encoder or decoder use
 * {@link getEncoders} or {@link getDecoders}.
 * @param ffmpegPath - Path to the ffmpeg executable.
 * @returns All codecs supported by ffmpeg.
 * @public
 */
export declare function getCodecs(ffmpegPath?: string): Promise<Codecs>;

/**
 * Returns all the decoders supported by ffmpeg as {@link Codecs}. This is mostly
 * useful to check if ffmpeg supports decoding a certain codec.
 * @param ffmpegPath - Path to the ffmpeg executable.
 * @example
 * ```ts
 * const decoders = await getDecoders();
 * if (decoders.video.has('h264')) {
 *   // h264 can be used for decoding
 * }
 * ```
 * @public
 */
export declare function getDecoders(ffmpegPath?: string): Promise<Codecs>;

/**
 * Returns a set of all demuxers supported by ffmpeg. This is mostly useful
 * to check if reading a certain format is supported.
 * @param ffmpegPath - Path to the ffmpeg executable.
 * @example
 * ```ts
 * const demuxers = await getDemuxers();
 * if (demuxers.has('mov')) {
 *   // mov can be used as an input format
 * }
 * ```
 * @public
 */
export declare function getDemuxers(ffmpegPath?: string): Promise<Set<string>>;

/**
 * Returns all the encoders supported by ffmpeg as {@link Codecs}. This is mostly
 * useful to check if ffmpeg supports encoding a certain codec.
 * @param ffmpegPath - Path to the ffmpeg executable.
 * @example
 * ```ts
 * const encoders = await getEncoders();
 * if (encoders.video.has('libx264')) {
 *   // libx264 can be used for encoding
 * }
 * ```
 * @public
 */
export declare function getEncoders(ffmpegPath?: string): Promise<Codecs>;

/**
 * @returns The absolute path to the default ffmpeg path. Defaults to `process.env.FFMPEG_PATH`.
 * @throws `TypeError` if the default path is `undefined`.
 * @public
 */
export declare function getFFmpegPath(): string;

/**
 * @returns The absolute path to the default ffprobe path. Defaults to `process.env.FFPROBE_PATH`.
 * @throws `TypeError` if the default path is `undefined`.
 * @public
 */
export declare function getFFprobePath(): string;

/**
 * Runs `ffmpeg -filters` and returns its output as {@link Filters}. This can be
 * used to check for compatibility or show a list of available filters to the user.
 * @param ffmpegPath - Path to the ffmpeg executable.
 * @public
 */
export declare function getFilters(ffmpegPath?: string): Promise<Filters>;

/**
 * Returns a set of all formats supported by ffmpeg. This is generally not very
 * useful, to check the compatibility for a certain format use {@link getMuxers}
 * for reading or {@link getDemuxers} for writing.
 * @param ffmpegPath - Path to the ffmpeg executable.
 * @public
 */
export declare function getFormats(ffmpegPath?: string): Promise<Set<string>>;

/**
 * Returns a set of all muxers supported by ffmpeg. This is mostly useful
 * to check if outputting a certain format is supported.
 * @param ffmpegPath - Path to the ffmpeg executable.
 * @example
 * ```ts
 * const muxers = await getMuxers();
 * if (muxers.has('mov')) {
 *   // mov can be used as an output format
 * }
 * ```
 * @public
 */
export declare function getMuxers(ffmpegPath?: string): Promise<Set<string>>;

/**
 * Runs `ffmpeg -pix_fmts` and returns its output as a set. This can be used to
 * check for compatibility or show a list of available formats to the user.
 * @param ffmpegPath - Path to the ffmpeg executable.
 * @example
 * ```ts
 * const pixelFormats = await getPixelFormats();
 * if (pixelFormats.has('yuv420p')) {
 *   // yuv420p is supported
 * }
 * ```
 * @public
 */
export declare function getPixelFormats(ffmpegPath?: string): Promise<Set<string>>;

/**
 * Runs `ffmpeg -version` and returns its output as {@link Version}.
 * @param ffmpegPath - Path to the ffmpeg executable.
 * @example
 * ```ts
 * const versionInfo = await getVersion();
 * console.log(`Using ffmpeg version ${versionInfo.version}`);
 * ```
 * @public
 */
export declare function getVersion(ffmpegPath?: string): Promise<Version>;

/** @public */
export declare type InputSource = string | Uint8Array | AsyncIterable<Uint8Array>;

/**
 * **UNSTABLE**: Support for logging is under consideration, this is not useful enough to recommend
 * its usage.
 *
 * @alpha
 */
export declare enum LogLevel {
    Quiet = "quiet",
    Panic = "panic",
    Fatal = "fatal",
    Error = "error",
    Warning = "warning",
    Info = "info",
    Verbose = "verbose",
    Debug = "debug",
    Trace = "trace"
}

/** @public */
export declare type Muxer = '3g2' | '3gp' | 'a64' | 'ac3' | 'adts' | 'adx' | 'aiff' | 'alaw' | 'amr' | 'apm' | 'apng' | 'aptx' | 'aptx_hd' | 'argo_asf' | 'asf' | 'asf_stream' | 'ass' | 'ast' | 'au' | 'avi' | 'avm2' | 'avs2' | 'bit' | 'caf' | 'cavsvideo' | 'codec2' | 'codec2raw' | 'crc' | 'dash' | 'data' | 'daud' | 'dirac' | 'dnxhd' | 'dts' | 'dv' | 'dvd' | 'eac3' | 'f32be' | 'f32le' | 'f4v' | 'f64be' | 'f64le' | 'ffmetadata' | 'fifo' | 'fifo_test' | 'film_cpk' | 'filmstrip' | 'fits' | 'flac' | 'flv' | 'framecrc' | 'framehash' | 'framemd5' | 'g722' | 'g723_1' | 'g726' | 'g726le' | 'gif' | 'gsm' | 'gxf' | 'h261' | 'h263' | 'h264' | 'hash' | 'hds' | 'hevc' | 'hls' | 'ico' | 'ilbc' | 'image2' | 'image2pipe' | 'ipod' | 'ircam' | 'ismv' | 'ivf' | 'jacosub' | 'kvag' | 'latm' | 'lrc' | 'm4v' | 'matroska' | 'md5' | 'microdvd' | 'mjpeg' | 'mkvtimestamp_v2' | 'mlp' | 'mmf' | 'mov' | 'mp2' | 'mp3' | 'mp4' | 'mpeg' | 'mpeg1video' | 'mpeg2video' | 'mpegts' | 'mpjpeg' | 'mulaw' | 'mxf' | 'mxf_d10' | 'mxf_opatom' | 'null' | 'nut' | 'oga' | 'ogg' | 'ogv' | 'oma' | 'opus' | 'psp' | 'rawvideo' | 'rm' | 'roq' | 'rso' | 'rtp' | 'rtp_mpegts' | 'rtsp' | 's16be' | 's16le' | 's24be' | 's24le' | 's32be' | 's32le' | 's8' | 'sap' | 'sbc' | 'scc' | 'sdl,sdl2' | 'segment' | 'singlejpeg' | 'smjpeg' | 'smoothstreaming' | 'sox' | 'spdif' | 'spx' | 'srt' | 'stream_segment,ssegment' | 'streamhash' | 'sup' | 'svcd' | 'swf' | 'tee' | 'truehd' | 'tta' | 'u16be' | 'u16le' | 'u24be' | 'u24le' | 'u32be' | 'u32le' | 'u8' | 'uncodedframecrc' | 'vc1' | 'vc1test' | 'vcd' | 'vidc' | 'vob' | 'voc' | 'w64' | 'wav' | 'webm' | 'webm_chunk' | 'webm_dash_manifest' | 'webp' | 'webvtt' | 'wtv' | 'wv' | 'yuv4mpegpipe';

/** @public */
export declare type OutputDestination = string | NodeJS.WritableStream;

/** @public */
export declare type PixelFormat = 'yuv420p' | 'yuyv422' | 'rgb24' | 'bgr24' | 'yuv422p' | 'yuv444p' | 'yuv410p' | 'yuv411p' | 'gray' | 'monow' | 'monob' | 'pal8' | 'yuvj420p' | 'yuvj422p' | 'yuvj444p' | 'uyvy422' | 'uyyvyy411' | 'bgr8' | 'bgr4' | 'bgr4_byte' | 'rgb8' | 'rgb4' | 'rgb4_byte' | 'nv12' | 'nv21' | 'argb' | 'rgba' | 'abgr' | 'bgra' | 'gray16be' | 'gray16le' | 'yuv440p' | 'yuvj440p' | 'yuva420p' | 'rgb48be' | 'rgb48le' | 'rgb565be' | 'rgb565le' | 'rgb555be' | 'rgb555le' | 'bgr565be' | 'bgr565le' | 'bgr555be' | 'bgr555le' | 'vaapi_moco' | 'vaapi_idct' | 'vaapi_vld' | 'yuv420p16le' | 'yuv420p16be' | 'yuv422p16le' | 'yuv422p16be' | 'yuv444p16le' | 'yuv444p16be' | 'dxva2_vld' | 'rgb444le' | 'rgb444be' | 'bgr444le' | 'bgr444be' | 'ya8' | 'bgr48be' | 'bgr48le' | 'yuv420p9be' | 'yuv420p9le' | 'yuv420p10be' | 'yuv420p10le' | 'yuv422p10be' | 'yuv422p10le' | 'yuv444p9be' | 'yuv444p9le' | 'yuv444p10be' | 'yuv444p10le' | 'yuv422p9be' | 'yuv422p9le' | 'gbrp' | 'gbrp9be' | 'gbrp9le' | 'gbrp10be' | 'gbrp10le' | 'gbrp16be' | 'gbrp16le' | 'yuva422p' | 'yuva444p' | 'yuva420p9be' | 'yuva420p9le' | 'yuva422p9be' | 'yuva422p9le' | 'yuva444p9be' | 'yuva444p9le' | 'yuva420p10be' | 'yuva420p10le' | 'yuva422p10be' | 'yuva422p10le' | 'yuva444p10be' | 'yuva444p10le' | 'yuva420p16be' | 'yuva420p16le' | 'yuva422p16be' | 'yuva422p16le' | 'yuva444p16be' | 'yuva444p16le' | 'vdpau' | 'xyz12le' | 'xyz12be' | 'nv16' | 'nv20le' | 'nv20be' | 'rgba64be' | 'rgba64le' | 'bgra64be' | 'bgra64le' | 'yvyu422' | 'ya16be' | 'ya16le' | 'gbrap' | 'gbrap16be' | 'gbrap16le' | 'qsv' | 'mmal' | 'd3d11va_vld' | 'cuda' | '0rgb' | 'rgb0' | '0bgr' | 'bgr0' | 'yuv420p12be' | 'yuv420p12le' | 'yuv420p14be' | 'yuv420p14le' | 'yuv422p12be' | 'yuv422p12le' | 'yuv422p14be' | 'yuv422p14le' | 'yuv444p12be' | 'yuv444p12le' | 'yuv444p14be' | 'yuv444p14le' | 'gbrp12be' | 'gbrp12le' | 'gbrp14be' | 'gbrp14le' | 'yuvj411p' | 'bayer_bggr8' | 'bayer_rggb8' | 'bayer_gbrg8' | 'bayer_grbg8' | 'bayer_bggr16le' | 'bayer_bggr16be' | 'bayer_rggb16le' | 'bayer_rggb16be' | 'bayer_gbrg16le' | 'bayer_gbrg16be' | 'bayer_grbg16le' | 'bayer_grbg16be' | 'xvmc' | 'yuv440p10le' | 'yuv440p10be' | 'yuv440p12le' | 'yuv440p12be' | 'ayuv64le' | 'ayuv64be' | 'videotoolbox_vld' | 'p010le' | 'p010be' | 'gbrap12be' | 'gbrap12le' | 'gbrap10be' | 'gbrap10le' | 'mediacodec' | 'gray12be' | 'gray12le' | 'gray10be' | 'gray10le' | 'p016le' | 'p016be' | 'd3d11' | 'gray9be' | 'gray9le' | 'gbrpf32be' | 'gbrpf32le' | 'gbrapf32be' | 'gbrapf32le' | 'drm_prime' | 'opencl' | 'gray14be' | 'gray14le' | 'grayf32be' | 'grayf32le' | 'yuva422p12be' | 'yuva422p12le' | 'yuva444p12be' | 'yuva444p12le' | 'nv24' | 'nv42' | 'vulkan' | 'y210be' | 'y210le' | 'x2rgb10le' | 'x2rgb10be';

/**
 * **UNSTABLE**
 *
 * Probes the given `source` using ffprobe.
 * @param source - The source to probe. Accepts the same types as `FFmpegCommand.input()`.
 * @param options - Customize ffprobe options.
 * @example
 * ```ts
 * const result = await probe('input.mp4');
 * console.log(result.format);
 * ```
 * @alpha
 */
export declare function probe(source: InputSource, options?: ProbeOptions): Promise<ProbeResult>;

/** @alpha */
export declare interface ProbeOptions {
    /**
     * Specify the number of bytes to probe, if not given it will not be specified in the command-line
     * arguments.
     */
    probeSize?: number;
    /**
     * Specify the number of milliseconds to analyze, defaults to `5000`.
     */
    analyzeDuration?: number;
    /**
     * Path to the `ffprobe` executable.
     */
    ffprobePath?: string;
    /**
     * **UNSTABLE**: Support for logging is under consideration.
     *
     * Set the log level used by ffprobe.
     * @alpha
     */
    logLevel?: LogLevel;
    /**
     * Specify the input format of the media to probe.
     */
    format?: Demuxer | Format | (string & {});
    /**
     * Add command line arguments to ffprobe, `args` is appended **after** other
     * arguments, but **before** source.
     */
    args?: string[];
    /**
     * Add custom options that will be used to spawn the process.
     * {@link https://nodejs.org/docs/latest-v12.x/api/child_process.html#child_process_child_process_spawn_command_args_options}
     * @example
     * ```ts
     * const info = await probe('video.mkv', {
     *   spawnOptions: {
     *     timeout: 5000
     *   }
     * });
     * ```
     */
    spawnOptions?: SpawnOptions_2;
}

/**
 * **UNSTABLE**: `ProbeResult` is intended to have a simple API but it is still very unfinished, for
 * the time being using `.unwrap()` is necessary to retrieve any useful information from `probe()`.
 *
 * @alpha
 */
export declare interface ProbeResult {
    format?: Demuxer | Format | (string & {});
    formatName?: string;
    start: number;
    duration: number;
    bitrate?: number;
    score: number;
    tags?: Map<string, string>;
    unwrap(): RawProbeResult;
}

/** @public */
export declare interface Progress {
    frames: number;
    fps: number;
    bitrate: number;
    bytes: number;
    time: number;
    framesDuped: number;
    framesDropped: number;
    speed: number;
}

/** @alpha */
export declare interface RawProbeChapter {
    id: number;
    time_base: string;
    start: number;
    start_time: string;
    end: number;
    end_time: string;
    tags?: Record<string, string>;
}

/** @alpha */
export declare interface RawProbeDisposition {
    default: number;
    dub: number;
    original: number;
    comment: number;
    lyrics: number;
    karaoke: number;
    forced: number;
    hearing_impaired: number;
    visual_impaired: number;
    clean_effects: number;
    attached_pic: number;
    timed_thumbnails: number;
}

/** @alpha */
export declare interface RawProbeError {
    code: number;
    string: string;
}

/** @alpha */
export declare interface RawProbeFormat {
    [key: string]: any;
    filename?: string;
    nb_streams: number;
    nb_programs: number;
    format_name?: string;
    format_long_name?: string;
    start_time: string;
    duration: string;
    size?: string;
    bit_rate?: string;
    probe_score: number;
    tags?: Record<string, string>;
}

/** @alpha */
export declare interface RawProbeResult {
    format: RawProbeFormat;
    streams: RawProbeStream[];
    chapters: RawProbeChapter[];
    error?: RawProbeError;
}

/** @alpha */
export declare type RawProbeStream = {
    [key: string]: any;
    index: number;
    codec_name?: string;
    codec_long_name?: string;
    profile?: string;
    codec_type: 'video';
    codec_time_base?: string;
    codec_tag_string: string;
    codec_tag: string;
    id?: string;
    r_frame_rate?: string;
    avg_frame_rate?: string;
    time_base?: string;
    start_pts?: string;
    start_time?: string;
    duration_ts?: string;
    duration?: string;
    bit_rate?: string;
    max_bit_rate?: string;
    bits_per_raw_sample?: number;
    nb_frames?: number;
    nb_read_frames?: number;
    nb_read_packets?: number;
    disposition?: RawProbeDisposition;
    width: number;
    height: number;
    coded_width?: number;
    coded_height?: number;
    closed_captions?: number;
    has_b_frames: number;
    sample_aspect_ratio?: string;
    display_aspect_ratio?: string;
    pix_fmt?: string;
    level: number;
    color_range?: string;
    color_space?: string;
    color_primaries?: string;
    chroma_location?: string;
    field_order?: string;
    timecode?: string;
    refs?: string;
    tags?: Record<string, string>;
} | {
    [key: string]: any;
    index: number;
    codec_name?: string;
    codec_long_name?: string;
    profile?: string;
    codec_type: 'audio';
    codec_time_base?: string;
    codec_tag_string: string;
    codec_tag: string;
    id?: string;
    r_frame_rate?: string;
    avg_frame_rate?: string;
    time_base?: string;
    start_pts?: string;
    start_time?: string;
    duration_ts?: string;
    duration?: string;
    bit_rate?: string;
    max_bit_rate?: string;
    bits_per_raw_sample?: number;
    nb_frames?: number;
    nb_read_frames?: number;
    nb_read_packets?: number;
    disposition?: RawProbeDisposition;
    sample_fmt?: string;
    sample_rate?: string;
    channels?: number;
    channel_layout?: string;
    bits_per_sample?: number;
    tags?: Record<string, string>;
} | {
    [key: string]: any;
    index: number;
    codec_name?: string;
    codec_long_name?: string;
    profile?: string;
    codec_type: 'subtitle';
    codec_time_base?: string;
    codec_tag_string: string;
    codec_tag: string;
    id?: string;
    r_frame_rate?: string;
    avg_frame_rate?: string;
    time_base?: string;
    start_pts?: string;
    start_time?: string;
    duration_ts?: string;
    duration?: string;
    bit_rate?: string;
    max_bit_rate?: string;
    bits_per_raw_sample?: number;
    nb_frames?: number;
    nb_read_frames?: number;
    nb_read_packets?: number;
    disposition?: RawProbeDisposition;
    width?: number;
    height?: number;
    tags?: Record<string, string>;
} | {
    [key: string]: any;
    index: number;
    codec_name?: string;
    codec_long_name?: string;
    profile?: string;
    codec_type?: string;
    codec_time_base?: string;
    codec_tag_string: string;
    codec_tag: string;
    id?: string;
    r_frame_rate?: string;
    avg_frame_rate?: string;
    time_base?: string;
    start_pts?: string;
    start_time?: string;
    duration_ts?: string;
    duration?: string;
    bit_rate?: string;
    max_bit_rate?: string;
    bits_per_raw_sample?: number;
    nb_frames?: number;
    nb_read_frames?: number;
    nb_read_packets?: number;
    disposition?: RawProbeDisposition;
    tags?: Record<string, string>;
};

/** @public */
export declare type SampleFormat = 'u8' | 's16' | 's32' | 'flt' | 'dbl' | 'u8p' | 's16p' | 's32p' | 'fltp' | 'dblp' | 's64' | 's64p';

/**
 * Manually override the default ffmpeg path.
 * @param path - Path to the ffmpeg executable. Relative paths CAN be used.
 * @throws `TypeError` if the given `path` is not a file.
 * @public
 */
export declare function setFFmpegPath(path: string): void;

/**
 * Manually override the default ffprobe path.
 * @param path - Path to the ffprobe executable. Relative paths CAN be used.
 * @throws `TypeError` if the `path` is not a file.
 * @public
 */
export declare function setFFprobePath(path: string): void;

/**
 * Start an FFmpeg process with the given arguments.
 * @param args - The arguments to spawn FFmpeg with.
 * @param ffmpegPath - Path to the ffmpeg executable. Defaults to `getFFmpegPath()`.
 * @public
 */
export declare function spawn(args: string[], ffmpegPath?: string): FFmpegProcess;

/** @public */
export declare interface SpawnOptions {
    /**
     * Path to the FFmpeg executable.
     */
    ffmpegPath?: string;
    /**
     * Add custom options that will be used to spawn the process.
     * {@link https://nodejs.org/docs/latest-v12.x/api/child_process.html#child_process_child_process_spawn_command_args_options}
     */
    spawnOptions?: SpawnOptions_2;
}

/** @public */
export declare type SubtitleCodec = 'arib_caption' | 'ass' | 'dvb_subtitle' | 'dvb_teletext' | 'dvd_subtitle' | 'eia_608' | 'hdmv_pgs_subtitle' | 'hdmv_text_subtitle' | 'jacosub' | 'microdvd' | 'mov_text' | 'mpl2' | 'pjs' | 'realtext' | 'sami' | 'srt' | 'ssa' | 'stl' | 'subrip' | 'subviewer' | 'subviewer1' | 'text' | 'ttml' | 'vplayer' | 'webvtt' | 'xsub';

/** @public */
export declare type SubtitleDecoder = 'ssa' | 'ass' | 'dvbsub' | 'dvdsub' | 'cc_dec' | 'pgssub' | 'jacosub' | 'microdvd' | 'mov_text' | 'mpl2' | 'pjs' | 'realtext' | 'sami' | 'stl' | 'srt' | 'subrip' | 'subviewer' | 'subviewer1' | 'text' | 'vplayer' | 'webvtt' | 'xsub';

/** @public */
export declare type SubtitleEncoder = 'ssa' | 'ass' | 'dvbsub' | 'dvdsub' | 'mov_text' | 'srt' | 'subrip' | 'text' | 'webvtt' | 'xsub';

/** @public */
export declare interface Version {
    copyright: string;
    version: string;
    configuration: string[];
    libavutil: string;
    libavcodec: string;
    libavformat: string;
    libavdevice: string;
    libavfilter: string;
    libswscale: string;
    libswresample: string;
    libpostproc: string;
}

/** @public */
export declare type VideoCodec = '012v' | '4xm' | '8bps' | 'a64_multi' | 'a64_multi5' | 'aasc' | 'agm' | 'aic' | 'alias_pix' | 'amv' | 'anm' | 'ansi' | 'apng' | 'arbc' | 'argo' | 'asv1' | 'asv2' | 'aura' | 'aura2' | 'av1' | 'avrn' | 'avrp' | 'avs' | 'avs2' | 'avui' | 'ayuv' | 'bethsoftvid' | 'bfi' | 'binkvideo' | 'bintext' | 'bitpacked' | 'bmp' | 'bmv_video' | 'brender_pix' | 'c93' | 'cavs' | 'cdgraphics' | 'cdtoons' | 'cdxl' | 'cfhd' | 'cinepak' | 'clearvideo' | 'cljr' | 'cllc' | 'cmv' | 'cpia' | 'cscd' | 'cyuv' | 'daala' | 'dds' | 'dfa' | 'dirac' | 'dnxhd' | 'dpx' | 'dsicinvideo' | 'dvvideo' | 'dxa' | 'dxtory' | 'dxv' | 'escape124' | 'escape130' | 'exr' | 'ffv1' | 'ffvhuff' | 'fic' | 'fits' | 'flashsv' | 'flashsv2' | 'flic' | 'flv1' | 'fmvc' | 'fraps' | 'frwu' | 'g2m' | 'gdv' | 'gif' | 'h261' | 'h263' | 'h263i' | 'h263p' | 'h264' | 'hap' | 'hevc' | 'hnm4video' | 'hq_hqa' | 'hqx' | 'huffyuv' | 'hymt' | 'idcin' | 'idf' | 'iff_ilbm' | 'imm4' | 'imm5' | 'indeo2' | 'indeo3' | 'indeo4' | 'indeo5' | 'interplayvideo' | 'ipu' | 'jpeg2000' | 'jpegls' | 'jv' | 'kgv1' | 'kmvc' | 'lagarith' | 'ljpeg' | 'loco' | 'lscr' | 'm101' | 'mad' | 'magicyuv' | 'mdec' | 'mimic' | 'mjpeg' | 'mjpegb' | 'mmvideo' | 'mobiclip' | 'motionpixels' | 'mpeg1video' | 'mpeg2video' | 'mpeg4' | 'msa1' | 'mscc' | 'msmpeg4v1' | 'msmpeg4v2' | 'msmpeg4v3' | 'msrle' | 'mss1' | 'mss2' | 'msvideo1' | 'mszh' | 'mts2' | 'mv30' | 'mvc1' | 'mvc2' | 'mvdv' | 'mvha' | 'mwsc' | 'mxpeg' | 'notchlc' | 'nuv' | 'paf_video' | 'pam' | 'pbm' | 'pcx' | 'pfm' | 'pgm' | 'pgmyuv' | 'pgx' | 'photocd' | 'pictor' | 'pixlet' | 'png' | 'ppm' | 'prores' | 'prosumer' | 'psd' | 'ptx' | 'qdraw' | 'qpeg' | 'qtrle' | 'r10k' | 'r210' | 'rasc' | 'rawvideo' | 'rl2' | 'roq' | 'rpza' | 'rscc' | 'rv10' | 'rv20' | 'rv30' | 'rv40' | 'sanm' | 'scpr' | 'screenpresso' | 'sgi' | 'sgirle' | 'sheervideo' | 'smackvideo' | 'smc' | 'smvjpeg' | 'snow' | 'sp5x' | 'speedhq' | 'srgc' | 'sunrast' | 'svg' | 'svq1' | 'svq3' | 'targa' | 'targa_y216' | 'tdsc' | 'tgq' | 'tgv' | 'theora' | 'thp' | 'tiertexseqvideo' | 'tiff' | 'tmv' | 'tqi' | 'truemotion1' | 'truemotion2' | 'truemotion2rt' | 'tscc' | 'tscc2' | 'txd' | 'ulti' | 'utvideo' | 'v210' | 'v210x' | 'v308' | 'v408' | 'v410' | 'vb' | 'vble' | 'vc1' | 'vc1image' | 'vcr1' | 'vixl' | 'vmdvideo' | 'vmnc' | 'vp3' | 'vp4' | 'vp5' | 'vp6' | 'vp6a' | 'vp6f' | 'vp7' | 'vp8' | 'vp9' | 'wcmv' | 'webp' | 'wmv1' | 'wmv2' | 'wmv3' | 'wmv3image' | 'wnv1' | 'wrapped_avframe' | 'ws_vqa' | 'xan_wc3' | 'xan_wc4' | 'xbin' | 'xbm' | 'xface' | 'xpm' | 'xwd' | 'y41p' | 'ylc' | 'yop' | 'yuv4' | 'zerocodec' | 'zlib' | 'zmbv';

/** @public */
export declare type VideoDecoder = '012v' | '4xm' | '8bps' | 'aasc' | 'agm' | 'aic' | 'alias_pix' | 'amv' | 'anm' | 'ansi' | 'apng' | 'arbc' | 'argo' | 'asv1' | 'asv2' | 'aura' | 'aura2' | 'libdav1d' | 'libaom-av1' | 'av1' | 'av1_qsv' | 'avrn' | 'avrp' | 'avs' | 'avui' | 'ayuv' | 'bethsoftvid' | 'bfi' | 'binkvideo' | 'bintext' | 'bitpacked' | 'bmp' | 'bmv_video' | 'brender_pix' | 'c93' | 'cavs' | 'cdgraphics' | 'cdtoons' | 'cdxl' | 'cfhd' | 'cinepak' | 'clearvideo' | 'cljr' | 'cllc' | 'eacmv' | 'cpia' | 'camstudio' | 'cyuv' | 'dds' | 'dfa' | 'dirac' | 'dnxhd' | 'dpx' | 'dsicinvideo' | 'dvvideo' | 'dxa' | 'dxtory' | 'dxv' | 'escape124' | 'escape130' | 'exr' | 'ffv1' | 'ffvhuff' | 'fic' | 'fits' | 'flashsv' | 'flashsv2' | 'flic' | 'flv' | 'fmvc' | 'fraps' | 'frwu' | 'g2m' | 'gdv' | 'gif' | 'h261' | 'h263' | 'h263i' | 'h263p' | 'h264' | 'h264_qsv' | 'h264_cuvid' | 'hap' | 'hevc' | 'hevc_qsv' | 'hevc_cuvid' | 'hnm4video' | 'hq_hqa' | 'hqx' | 'huffyuv' | 'hymt' | 'idcinvideo' | 'idf' | 'iff' | 'imm4' | 'imm5' | 'indeo2' | 'indeo3' | 'indeo4' | 'indeo5' | 'interplayvideo' | 'ipu' | 'jpeg2000' | 'libopenjpeg' | 'jpegls' | 'jv' | 'kgv1' | 'kmvc' | 'lagarith' | 'loco' | 'lscr' | 'm101' | 'eamad' | 'magicyuv' | 'mdec' | 'mimic' | 'mjpeg' | 'mjpeg_cuvid' | 'mjpeg_qsv' | 'mjpegb' | 'mmvideo' | 'mobiclip' | 'motionpixels' | 'mpeg1video' | 'mpeg1_cuvid' | 'mpeg2video' | 'mpegvideo' | 'mpeg2_qsv' | 'mpeg2_cuvid' | 'mpeg4' | 'mpeg4_cuvid' | 'msa1' | 'mscc' | 'msmpeg4v1' | 'msmpeg4v2' | 'msmpeg4' | 'msrle' | 'mss1' | 'mss2' | 'msvideo1' | 'mszh' | 'mts2' | 'mv30' | 'mvc1' | 'mvc2' | 'mvdv' | 'mvha' | 'mwsc' | 'mxpeg' | 'notchlc' | 'nuv' | 'paf_video' | 'pam' | 'pbm' | 'pcx' | 'pfm' | 'pgm' | 'pgmyuv' | 'pgx' | 'photocd' | 'pictor' | 'pixlet' | 'png' | 'ppm' | 'prores' | 'prosumer' | 'psd' | 'ptx' | 'qdraw' | 'qpeg' | 'qtrle' | 'r10k' | 'r210' | 'rasc' | 'rawvideo' | 'rl2' | 'roqvideo' | 'rpza' | 'rscc' | 'rv10' | 'rv20' | 'rv30' | 'rv40' | 'sanm' | 'scpr' | 'screenpresso' | 'sgi' | 'sgirle' | 'sheervideo' | 'smackvid' | 'smc' | 'smvjpeg' | 'snow' | 'sp5x' | 'speedhq' | 'srgc' | 'sunrast' | 'svq1' | 'svq3' | 'targa' | 'targa_y216' | 'tdsc' | 'eatgq' | 'eatgv' | 'theora' | 'thp' | 'tiertexseqvideo' | 'tiff' | 'tmv' | 'eatqi' | 'truemotion1' | 'truemotion2' | 'truemotion2rt' | 'camtasia' | 'tscc2' | 'txd' | 'ultimotion' | 'utvideo' | 'v210' | 'v210x' | 'v308' | 'v408' | 'v410' | 'vb' | 'vble' | 'vc1' | 'vc1_qsv' | 'vc1_cuvid' | 'vc1image' | 'vcr1' | 'xl' | 'vmdvideo' | 'vmnc' | 'vp3' | 'vp4' | 'vp5' | 'vp6' | 'vp6a' | 'vp6f' | 'vp7' | 'vp8' | 'libvpx' | 'vp8_cuvid' | 'vp8_qsv' | 'vp9' | 'libvpx-vp9' | 'vp9_cuvid' | 'vp9_qsv' | 'wcmv' | 'webp' | 'wmv1' | 'wmv2' | 'wmv3' | 'wmv3image' | 'wnv1' | 'wrapped_avframe' | 'vqavideo' | 'xan_wc3' | 'xan_wc4' | 'xbin' | 'xbm' | 'xface' | 'xpm' | 'xwd' | 'y41p' | 'ylc' | 'yop' | 'yuv4' | 'zerocodec' | 'zlib' | 'zmbv';

/** @public */
export declare type VideoEncoder = 'a64multi' | 'a64multi5' | 'alias_pix' | 'amv' | 'apng' | 'asv1' | 'asv2' | 'libaom-av1' | 'librav1e' | 'libsvtav1' | 'avrp' | 'avui' | 'ayuv' | 'bmp' | 'cfhd' | 'cinepak' | 'cljr' | 'vc2' | 'dnxhd' | 'dpx' | 'dvvideo' | 'ffv1' | 'ffvhuff' | 'fits' | 'flashsv' | 'flashsv2' | 'flv' | 'gif' | 'h261' | 'h263' | 'h263p' | 'libx264' | 'libx264rgb' | 'h264_amf' | 'h264_mf' | 'h264_nvenc' | 'h264_qsv' | 'nvenc' | 'nvenc_h264' | 'libx265' | 'nvenc_hevc' | 'hevc_amf' | 'hevc_mf' | 'hevc_nvenc' | 'hevc_qsv' | 'huffyuv' | 'jpeg2000' | 'libopenjpeg' | 'jpegls' | 'ljpeg' | 'magicyuv' | 'mjpeg' | 'mjpeg_qsv' | 'mpeg1video' | 'mpeg2video' | 'mpeg2_qsv' | 'mpeg4' | 'libxvid' | 'msmpeg4v2' | 'msmpeg4' | 'msvideo1' | 'pam' | 'pbm' | 'pcx' | 'pgm' | 'pgmyuv' | 'png' | 'ppm' | 'prores' | 'prores_aw' | 'prores_ks' | 'qtrle' | 'r10k' | 'r210' | 'rawvideo' | 'roqvideo' | 'rpza' | 'rv10' | 'rv20' | 'sgi' | 'snow' | 'sunrast' | 'svq1' | 'targa' | 'libtheora' | 'tiff' | 'utvideo' | 'v210' | 'v308' | 'v408' | 'v410' | 'libvpx' | 'libvpx-vp9' | 'vp9_qsv' | 'libwebp_anim' | 'libwebp' | 'wmv1' | 'wmv2' | 'wrapped_avframe' | 'xbm' | 'xface' | 'xwd' | 'y41p' | 'yuv4' | 'zlib' | 'zmbv';

/** @public */
export declare type VideoFilter = 'addroi' | 'alphaextract' | 'alphamerge' | 'amplify' | 'ass' | 'atadenoise' | 'avgblur' | 'bbox' | 'bench' | 'bilateral' | 'bitplanenoise' | 'blackdetect' | 'blackframe' | 'blend' | 'boxblur' | 'bwdif' | 'cas' | 'chromahold' | 'chromakey' | 'chromanr' | 'chromashift' | 'ciescope' | 'codecview' | 'colorbalance' | 'colorchannelmixer' | 'colorkey' | 'colorhold' | 'colorlevels' | 'colormatrix' | 'colorspace' | 'convolution' | 'convolve' | 'copy' | 'cover_rect' | 'crop' | 'cropdetect' | 'cue' | 'curves' | 'datascope' | 'dblur' | 'dctdnoiz' | 'deband' | 'deblock' | 'deconvolve' | 'dedot' | 'deflate' | 'deflicker' | 'deinterlace_qsv' | 'dejudder' | 'delogo' | 'derain' | 'deshake' | 'despill' | 'detelecine' | 'dilation' | 'displace' | 'dnn_processing' | 'doubleweave' | 'drawbox' | 'drawgraph' | 'drawgrid' | 'drawtext' | 'edgedetect' | 'elbg' | 'entropy' | 'eq' | 'erosion' | 'extractplanes' | 'fade' | 'fftdnoiz' | 'fftfilt' | 'field' | 'fieldhint' | 'fieldorder' | 'fillborders' | 'find_rect' | 'floodfill' | 'format' | 'fps' | 'framepack' | 'framerate' | 'framestep' | 'freezedetect' | 'freezeframes' | 'fspp' | 'gblur' | 'geq' | 'gradfun' | 'graphmonitor' | 'greyedge' | 'haldclut' | 'hflip' | 'histeq' | 'histogram' | 'hqdn3d' | 'hqx' | 'hue' | 'hwdownload' | 'hwmap' | 'hwupload' | 'hwupload_cuda' | 'hysteresis' | 'idet' | 'il' | 'inflate' | 'interlace' | 'kerndeint' | 'lagfun' | 'lenscorrection' | 'limiter' | 'loop' | 'lumakey' | 'lut' | 'lut1d' | 'lut2' | 'lut3d' | 'lutrgb' | 'lutyuv' | 'maskedclamp' | 'maskedmax' | 'maskedmerge' | 'maskedmin' | 'maskedthreshold' | 'maskfun' | 'mcdeint' | 'median' | 'mestimate' | 'metadata' | 'midequalizer' | 'minterpolate' | 'mpdecimate' | 'negate' | 'nlmeans' | 'nnedi' | 'noformat' | 'noise' | 'normalize' | 'null' | 'oscilloscope' | 'overlay' | 'overlay_qsv' | 'overlay_cuda' | 'owdenoise' | 'pad' | 'palettegen' | 'paletteuse' | 'perms' | 'perspective' | 'phase' | 'photosensitivity' | 'pixdesctest' | 'pixscope' | 'pp' | 'pp7' | 'prewitt' | 'pseudocolor' | 'psnr' | 'pullup' | 'qp' | 'random' | 'readeia608' | 'readvitc' | 'realtime' | 'remap' | 'removegrain' | 'removelogo' | 'repeatfields' | 'reverse' | 'rgbashift' | 'roberts' | 'rotate' | 'sab' | 'scale' | 'scale_cuda' | 'scale_qsv' | 'scale2ref' | 'scdet' | 'scroll' | 'select' | 'selectivecolor' | 'sendcmd' | 'separatefields' | 'setdar' | 'setfield' | 'setparams' | 'setpts' | 'setrange' | 'setsar' | 'settb' | 'showinfo' | 'showpalette' | 'shuffleframes' | 'shuffleplanes' | 'sidedata' | 'signalstats' | 'smartblur' | 'sobel' | 'split' | 'spp' | 'sr' | 'ssim' | 'stereo3d' | 'subtitles' | 'super2xsai' | 'swaprect' | 'swapuv' | 'tblend' | 'telecine' | 'thistogram' | 'threshold' | 'thumbnail' | 'thumbnail_cuda' | 'tile' | 'tinterlace' | 'tlut2' | 'tmedian' | 'tmix' | 'tonemap' | 'tpad' | 'transpose' | 'trim' | 'unsharp' | 'untile' | 'uspp' | 'v360' | 'vaguedenoiser' | 'vectorscope' | 'vflip' | 'vfrdet' | 'vibrance' | 'vidstabdetect' | 'vidstabtransform' | 'vignette' | 'vmafmotion' | 'vpp_qsv' | 'w3fdif' | 'waveform' | 'weave' | 'xbr' | 'xfade' | 'yadif' | 'yadif_cuda' | 'yaepblur' | 'zoompan' | 'zscale' | 'nullsink' | 'spectrumsynth' | 'fifo' | 'buffersink';

export { }
